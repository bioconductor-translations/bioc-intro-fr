---
source: Rmd
title: Manipulating and analysing data with dplyr
teaching: 75
exercises: 75
---

```{r, include=FALSE}

```

::::::::::::::::::::::::::::::::::::::: objectives

- Describe the purpose of the **`dplyr`** and **`tidyr`** packages.
- Describe several of their functions that are extremely useful to
 manipulate data.
- Describe the concept of a wide and a long table format, and see
 how to reshape a data frame from one format to the other one.
- Montrer comment joindre des tables.

::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::: questions

- Data analysis in R using the tidyverse meta-package

::::::::::::::::::::::::::::::::::::::::::::::::::

```{r loaddata_dplyr, echo=FALSE, purl=FALSE, message=FALSE}
if (!file.exists("data/rnaseq.csv"))
download.file(url = "https://github.com/carpentries-incubator/bioc-intro/raw/main/episodes/data/rnaseq.csv",
              destfile = "data/rnaseq.csv")
```

> Cet épisode est basé sur la leçon _Analyse des données et
> Visualisation dans R pour les écologistes_ de Data Carpentries.

## Data manipulation using **`dplyr`** and **`tidyr`**

Extraire un sous-ensemble avec les crochets est pratique, mais peut être fastidieux et difficile à lire, en particulier pour les opérations compliquées.

Some packages can greatly facilitate our task when we manipulate data.
Les packages dans R sont essentiellement des ensembles de fonctions supplémentaires qui vous permettent de faire plus de choses. Les fonctions que nous avons utilisées jusqu'à présent, comme `str()` ou
`data.frame()`, sont intégrées à R ; le chargement de packages donne accès à d'autres fonctions spécifiques. Before you use a package for the first time you need to install
it on your machine, and then you should import it in every subsequent
R session when you need it.

- The package **`dplyr`** provides powerful tools for data manipulation tasks.
 It is built to work directly with data frames, with many manipulation tasks
 optimised.

- As we will see latter on, sometimes we want a data frame to be reshaped to be able
 to do some specific analyses or for visualisation. The package **`tidyr`** addresses
 this common problem of reshaping data and provides tools for manipulating
 data in a tidy way.

To learn more about **`dplyr`** and **`tidyr`** after the workshop,
you may want to check out this handy data transformation with

- The **`tidyverse`** package is an "umbrella-package" that installs
 several useful packages for data analysis which work well together,
 such as **`tidyr`**, **`dplyr`**, **`ggplot2`**, **`tibble`**, etc.
 These packages help us to work and interact with the data.
 They allow us to do many things with your data, such as subsetting, transforming,
 visualising, etc.

If you did the set up, you should have already installed the tidyverse package.
Vérifiez si vous l'avez en essayant de le charger depuis la librarie (library) :

```{r load_dplyr, message=FALSE, purl=TRUE}
## load the tidyverse packages, incl. dplyr
library("tidyverse")
```

If you got an error message `there is no package called ‘tidyverse’` then you have not
installed the package yet for this version of R. To install the **`tidyverse`** package type:

```{r install_tidyverse, eval=FALSE, purl=TRUE}
BiocManager::install("tidyverse")
```

If you had to install the **`tidyverse`** package, do not forget to load it in this R session by using the `library()` command above!

## Loading data with tidyverse

Instead of `read.csv()`, we will read in our data using the `read_csv()`
function (notice the `_` instead of the `.`), from the tidyverse package
**`readr`**.

```{r read_csv, message=FALSE, purl=TRUE}
rna <- read_csv("data/rnaseq.csv")

## view the data
rna
```

Notez que la classe de la variable est désormais appelée "tibble".

Les tibbles modifient certains comportements des objets data frame que nous avons introduits précédemment. La structure des données est très similaire à un data frame. Pour nos besoins, les seules différences sont les suivantes :

1. It displays the data type of each column under its name.
 Note that \<`dbl`\> is a data type defined to hold numeric values with
 decimal points.

2. It only prints the first few rows of data and only as many columns as fit on
 one screen.

We are now going to learn some of the most common **`dplyr`** functions:

- `select()` : extraire des sous-ensembles de colonnes
- `filter()` : extraire des sous-ensembles de lignes
- `mutate()` : crée de nouvelles colonnes en utilisant les informations de colonnes préexistantes
- `group_by()` and `summarise()`: create summary statistics on grouped data
- `arrange()`: sort results
- `count()` : compte des valeurs discrètes

## Selecting columns and filtering rows

To select columns of a data frame, use `select()`. Le premier argument
de cette fonction est le dataframe (`rna`), et les arguments
suivants reprennent les colonnes à conserver.

```{r select1, purl=TRUE}
select(rna, gene, sample, tissue, expression)
```

To select all columns _except_ certain ones, put a "-" in front of
the variable to exclude it.

```{r select2, purl=TRUE}
select(rna, -tissue, -organism)
```

Cela sélectionnera toutes les variables de `rna` sauf `tissue`
et `organism`.

To choose rows based on a specific criteria, use `filter()`:

```{r filter1, purl=TRUE}
filter(rna, sex == "Male")
filter(rna, sex == "Male" & infection == "NonInfected")
```

Imaginons maintenant que nous nous intéressions aux homologues humains des gènes
de souris analysés dans ces données. Ces informations se trouvent dans la dernière colonne du tibble `rna`, nommée `hsapiens_homolog_associated_gene_name`.  To visualise it easily, we
will create a new table containing just the 2 columns `gene` and
`hsapiens_homolog_associated_gene_name`.

```{r select3}
genes <- select(rna, gene, hsapiens_homolog_associated_gene_name)
genes
```

Some mouse genes have no human homologs. These can be retrieved using
`filter()` and the `is.na()` function, that determines whether
something is an `NA`.

```{r filter2, purl=TRUE}
filter(genes, is.na(hsapiens_homolog_associated_gene_name))
```

If we want to keep only mouse genes that have a human homolog, we can
insert a "!" symbol that negates the result, so we're asking for
every row where hsapiens\_homolog\_associated\_gene\_name _is not_ an
`NA`.

```{r, purl=TRUE}
filter(genes, !is.na(hsapiens_homolog_associated_gene_name))
```

## Pipes

Comment faire si vous souhaitez sélectionner et filtrer en même temps ? Il existe trois
façons de procéder : utiliser des étapes intermédiaires, des fonctions imbriquées ou des _pipes_.

Avec des étapes intermédiaires, vous créez un data frame temporaire et l'utilisez
comme entrée de la fonction suivante, comme ceci :

```{r pipemotiv1, purl=TRUE}
rna2 <- filter(rna, sex == "Male")
rna3 <- select(rna2, gene, sample, tissue, expression)
rna3
```

This is readable, but can clutter up your workspace with lots of
intermediate objects that you have to name individually. Avec beaucoup d'étapes, cette approche devient difficile à suivre.

You can also nest functions (i.e. one function inside of another),
like this:

```{r pipemotiv2, purl=TRUE}
rna3 <- select(filter(rna, sex == "Male"), gene, sample, tissue, expression)
rna3
```

Cette approche est pratique, mais peut être difficile à lire si trop de fonctions sont imbriquées, car R évalue l'expression de l'intérieur vers l'extérieur (dans ce cas, filtrer, puis sélectionner).

The last option, _pipes_, are a recent addition to R. Pipes let you take
the output of one function and send it directly to the next, which is useful
when you need to do many things to the same dataset.

Les _pipes_ dans R s'écrivent à `%>%` (mis à disposition via le package `magrittr`) ou `|>` (via R). Si vous utilisez RStudio, vous pouvez afficher un _pipe_ avec <kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>M</kbd> sur un PC ou <kbd>Cmd</kbd> + <kbd>Shift</kbd> + <kbd>M</kbd> sur un Mac.

Dans le code ci-dessus, nous utilisons le _pipe_ pour passer les données `rna` d'abord
dans `filter()` pour conserver les lignes où `sex` est égal à `"Male"`, puis dans `select()` pour conserver uniquement les colonnes `gene`, `sample`, `tissue` et `expression`.

The pipe `|>` takes the object on its left and passes it directly as
the first argument to the function on its right, we don't need to
explicitly include the data frame as an argument to the `filter()` and
`select()` functions any more.

```{r usepipe, purl=TRUE}
rna |>
  filter(sex == "Male") |>
  select(gene, sample, tissue, expression)
```

Certains trouveront peut-être utile de lire le _pipe_ comme le mot "ensuite". For instance,
in the above example, we took the data frame `rna`, _then_ we `filter`ed
for rows with `sex == "Male"`, _then_ we `select`ed columns `gene`, `sample`,
`tissue`, and `expression`.

The **`dplyr`** functions by themselves are somewhat simple, but by
combining them into linear workflows with the pipe, we can accomplish
more complex manipulations of data frames.

Si nous voulons créer un nouvel objet avec cette version plus petite des données, il suffit de
lui attribuer un nouveau nom :

```{r, purl=TRUE}
rna3 <- rna |>
  filter(sex == "Male") |>
  select(gene, sample, tissue, expression)

rna3
```

:::::::::::::::::::::::::::::::::::::::  challenge

## Défi:

À l'aide de _pipes_, extraire un sous-ensemble de `rna` pour ne conserver que les observations des souris femelles au temps 0, où le gène a une expression supérieure à 50000, et ne conservez que les colonnes
`gene`, `sample `, `time`, `expression` et `age`.

:::::::::::::::  solution

## Solution

```{r}
rna |>
  filter(expression > 50000,
         sex == "Female",
         time == 0 ) |>
  select(gene, sample, time, expression, age)
```

:::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::::

## Mutate

Frequently you'll want to create new columns based on the values of existing
columns, for example to do unit conversions, or to find the ratio of values in two
columns. Pour cela, nous utiliserons la fonction `mutate()`.

To create a new column of time in hours:

```{r, purl=TRUE}
rna |>
  mutate(time_hours = time * 24) |>
  select(time, time_hours)
```

You can also create a second new column based on the first new column within the same call of `mutate()`:

```{r, purl=TRUE}
rna |>
  mutate(time_hours = time * 24,
         time_mn = time_hours * 60) |>
  select(time, time_hours, time_mn)
```

:::::::::::::::::::::::::::::::::::::::  challenge

## Challenge

Créez un nouveau data frane à partir de `rna` qui répond aux critères
suivants : contient uniquement les colonnes `gene`, `chromosome_name`,
`phenotype_description`, `sample` et `expression`. Les valeurs d'expression
doivent être transformées en log. Ce data frame doit
contenir uniquement des gènes situés sur les chromosomes sexuels, ayant bien un `phenotype
\_description`, et une expression en log supérieure à 5.

**Astuce** : réfléchissez bien à la façon dont les commandes doivent être ordonnées !

:::::::::::::::  solution

## Solution

```{r, eval=TRUE, purl=TRUE}
rna |>
  mutate(expression = log(expression)) |>
  select(gene, chromosome_name, phenotype_description, sample, expression) |>
  filter(chromosome_name == "X" | chromosome_name == "Y") |>
  filter(!is.na(phenotype_description)) |>
  filter(expression > 5)
```

:::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::::

## Analyse de données "split-apply-combine"

Many data analysis tasks can be approached using the
_split-apply-combine_ paradigm: split the data into groups, apply some
analysis to each group, and then combine the results. **`dplyr`**
makes this very easy through the use of the `group_by()` function.

```{r}
rna |>
  group_by(gene)
```

La fonction `group_by()` n'effectue aucun traitement de données, elle
regroupe simplement les données en sous-ensembles : dans l'exemple ci-dessus, notre
`tibble` initial de `r nrow(rna)` observations est divisé en
`r length(unique(rna$gene))` groupes selon la variable `gene`.

On pourrait de même décider de regrouper le tibble par échantillons :

```{r}
rna |>
  group_by(sample)
```

Ici, notre `tibble` initial de `r nrow(rna)` observations est divisé en
`r length(unique(rna$sample))` groupes selon la variable `sample`.

Une fois les données regroupées, les opérations qui suivent sont
appliquées sur chaque groupe indépendamment.

### La fonction `summarise()`

`group_by()` est souvent utilisé avec `summarise()`, qui
réduit chaque groupe en un résumé d'une seule ligne.

`group_by()` prend comme arguments les noms de colonnes qui contiennent les variables
**catégorielles** pour lesquelles vous souhaitez calculer les statistiques récapitulatives. So to compute the mean `expression` by gene:

```{r}
rna |>
  group_by(gene) |>
  summarise(mean_expression = mean(expression))
```

We could also want to calculate the mean expression levels of all genes in each sample:

```{r}
rna |>
  group_by(sample) |>
  summarise(mean_expression = mean(expression))
```

On peut également regrouper les observations par plusieurs colonnes :

```{r}
rna |>
  group_by(gene, infection, time) |>
  summarise(mean_expression = mean(expression))
```

Once the data is grouped, you can also summarise multiple variables at the same
time (and not necessarily on the same variable). For instance, we could add a
column indicating the median `expression` by gene and by condition:

```{r, purl=TRUE}
rna |>
  group_by(gene, infection, time) |>
  summarise(mean_expression = mean(expression),
            median_expression = median(expression))
```

:::::::::::::::::::::::::::::::::::::::  challenge

## Challenge

Calculer le niveau d’expression moyen du gène "Dok3" pour chaque temps.

:::::::::::::::  solution

## Solution

```{r, purl=TRUE}
rna |>
  filter(gene == "Dok3") |>
  group_by(time) |>
  summarise(mean = mean(expression))
```

:::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::::

### Count

When working with data, we often want to know the number of observations found
for each factor or combination of factors. For this task, **`dplyr`** provides
`count()`. Par exemple, si nous voulons compter le nombre d'observations pour
chaque échantillon infecté et non infecté :

```{r, purl=TRUE}
rna |>
    count(infection)
```

La fonction `count()` est un raccourci pour quelque chose que nous avons déjà vu : regrouper par une variable et la résumer en comptant le nombre d'observations dans ce groupe. In other words, `rna |> count(infection)` is equivalent to:

```{r, purl=TRUE}
rna |>
    group_by(infection) |>
    summarise(n = n())
```

The previous example shows the use of `count()` to count the number of rows/observations
for _one_ factor (i.e., `infection`).
If we wanted to count a _combination of factors_, such as `infection` and `time`,
we would specify the first and the second factor as the arguments of `count()`:

```{r, purl=TRUE}
rna |>
    count(infection, time)
```

which is equivalent to this:

```{r, purl=TRUE}
rna |>
  group_by(infection, time) |>
  summarise(n = n())
```

It is sometimes useful to sort the result to facilitate the comparisons.
We can use `arrange()` to sort the table.
Par exemple, nous pourrions vouloir organiser le tableau ci-dessus par temps :

```{r, purl=TRUE}
rna |>
  count(infection, time) |>
  arrange(time)
```

ou par comptage :

```{r, purl=TRUE}
rna |>
  count(infection, time) |>
  arrange(n)
```

To sort in descending order, we need to add the `desc()` function:

```{r, purl=TRUE}
rna |>
  count(infection, time) |>
  arrange(desc(n))
```

:::::::::::::::::::::::::::::::::::::::  challenge

## Challenge

1. How many genes were analysed in each sample?
2. Use `group_by()` and `summarise()` to evaluate the sequencing depth (the sum of all counts) in each sample. Which sample has the highest sequencing depth?
3. Pick one sample and evaluate the number of genes by biotype.
4. Identifiez les gènes associés à la description du phénotype "abnormal DNA methylation" et calculez leur expression moyenne (en log) au temps 0, 4 et 8.

:::::::::::::::  solution

## Solution

```{r}
## 1.
rna |>
  count(sample)
## 2.
rna |>
  group_by(sample) |>
  summarise(seq_depth = sum(expression)) |>
  arrange(desc(seq_depth))
## 3.
rna |>
  filter(sample == "GSM2545336") |>
  count(gene_biotype) |>
  arrange(desc(n))
## 4.
rna |>
  filter(phenotype_description == "abnormal DNA methylation") |>
  group_by(gene, time) |>
  summarise(mean_expression = mean(log(expression))) |>
  arrange()
```

:::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::::

## Reshaping data

Dans le tibble `rna`, les lignes contiennent des valeurs d'expression qui sont associées à une combinaison de 2 autres variables : `gene` et `sample`.

All the other columns correspond to variables describing either
the sample (organism, age, sex, ...) soit le gène ('gene_biotype', 'ENTREZ_ID', 'product', ...).
The variables that don't change with genes or with samples will have the same value in all the rows.

```{r}
rna |>
  arrange(gene)
```

Cette structure est appelée "format long", car une colonne contient toutes les valeurs,
et d'autres colonnes répertorient le contexte de la valeur.

Dans certains cas, le "format long" n'est pas facile à lire, et un autre format, un "format large" est préféré, comme manière plus compacte de représenter les données.
Cela est typiquement le cas pour des données d'expression de gènes, qui sont généralement représentées sous forme de matrice où les gènes sont repris le long des lignes et les échantillons le long des colonnes.

Dans ce format, il devient donc simple
d'explorer la relation entre les niveaux d'expression génique au sein et
entre les échantillons.

```{r, echo=FALSE}
rna |>
  select(gene, sample, expression) |>
  pivot_wider(names_from = sample,
              values_from = expression)
```

To convert the gene expression values from `rna` into a wide-format,
we need to create a new table where the values of the `sample` column would
become the names of column variables.

Nous **remodellons** les données en fonction des observations d'intérêt, tout en continant à suivre les principles des données tidy: niveaux d'expression par gène au lieu des les afficher par gènes et par échantillons.

The opposite transformation would be to transform column names into
values of a new variable.

We can do both these of transformations with two `tidyr` functions,
`pivot_longer()` and `pivot_wider()` (see
[here](https://tidyr.tidyverse.org/dev/articles/pivot.html) for
details).

### Pivoter les données en format large

Sélectionnons les 3 premières colonnes de `rna` et utilisons `pivot_wider()`
pour transformer les données en format large.

```{r, purl=TRUE}
rna_exp <- rna |>
  select(gene, sample, expression)
rna_exp
```

`pivot_wider` takes three main arguments:

1. the data to be transformed;
2. the `names_from` : the column whose values will become new column
 names;
3. the `values_from`: the column whose values will fill the new
 columns.

```{r, fig.cap="Wide pivot of the `rna\` data.", echo=FALSE, message=FALSE}
knitr::include_graphics("fig/pivot_wider.png")

```

```{r, purl=TRUE}
rna_wide <- rna_exp |>
  pivot_wider(names_from = sample,
              values_from = expression)
rna_wide
```

Note that by default, the `pivot_wider()` function will add `NA` for missing values.

Imaginons que nous ayons des valeurs d'expression manquantes pour certains gènes
dans certains échantillons. Dans cet exemple, le gène Cyp2d22 n'aune donnée d'expression que pour l'echantillon GSM2545338.

```{r, purl=TRUE}
rna_with_missing_values <- rna |>
  select(gene, sample, expression) |>
  filter(gene %in% c("Asl", "Apod", "Cyp2d22")) |>
  filter(sample %in% c("GSM2545336", "GSM2545337", "GSM2545338")) |>
  arrange(sample) |>
  filter(!(gene == "Cyp2d22" & sample != "GSM2545338"))
rna_with_missing_values
```

By default, the `pivot_wider()` function will add `NA` for missing
values. This can be parameterised with the `values_fill` argument of
the `pivot_wider()` function.

```{r, purl=TRUE}
rna_with_missing_values |>
  pivot_wider(names_from = sample,
              values_from = expression)

rna_with_missing_values |>
  pivot_wider(names_from = sample,
              values_from = expression,
              values_fill = 0)
```

### Pivoter les données en format long

Dans la situation inverse, nous utilisons les noms de colonnes et les transformons en deux nouvelles variables. Une variable représente le nom de colonne contenant les valeurs, et l'autre contenant les valeurs précédemment
associées aux noms de colonnes.

`pivot_longer()` prend quatre arguments principaux :

1. the data to be transformed;
2. the `names_to`: the new column name we wish to create and populate with the
 current column names;
3. the `values_to`: the new column name we wish to create and populate with
 current values;
4. les noms des colonnes à utiliser pour renseigner les variables `names_to` et
 `values_to` (ou à ignorer).

```{r, fig.cap="Long pivot of the `rna\` data.", echo=FALSE, message=FALSE}
knitr::include_graphics("fig/pivot_longer.png")

```

To recreate `rna_long` from `rna_wide` we would create a key
called `sample` and value called `expression` and use all columns
except `gene` for the key variable. Here we drop `gene` column
with a minus sign.

Notice how the new variable names are to be quoted here.

```{r}
rna_long <- rna_wide |>
    pivot_longer(names_to = "sample",
                 values_to = "expression",
                 -gene)
rna_long
```

Nous aurions également pu spécifier les colonnes à
inclure. Quand il faut inclure un grand nombre de colonnes, et il est plus facile de spécifier ce qu'il faut rassembler que ce qu'il faut ignorer. Ici, la fonction `starts_with()` peut aider à récupérer des colonnes
sans avoir à toutes les énumérer !
Another possibility would be to use the `:` operator!

```{r}
rna_wide |>
    pivot_longer(names_to = "sample",
                 values_to = "expression",
                 cols = starts_with("GSM"))
rna_wide |>
    pivot_longer(names_to = "sample",
                 values_to = "expression",
                 GSM2545336:GSM2545380)
```

Notez que si nous avions des valeurs manquantes dans le format large, le `NA` serait
inclus dans le nouveau format long.

Remember our previous fictive tibble containing missing values:

```{r}
rna_with_missing_values

wide_with_NA <- rna_with_missing_values |>
  pivot_wider(names_from = sample,
              values_from = expression)
wide_with_NA

wide_with_NA |>
    pivot_longer(names_to = "sample",
                 values_to = "expression",
                 -gene)
```

Passer à des formats larges et longs peut être un moyen utile d'équilibrer un ensemble de données afin que chaque réplique ait la même composition.

:::::::::::::::::::::::::::::::::::::::  challenge

## Question

A partir de la table `rna`, utilisez la fonction `pivot_wider()` pour créer un tableau au format large donnant les niveaux d'expression génique chez chaque souris.
Utilisez ensuite la fonction `pivot_longer()` pour restaurer le tableau au format long.

:::::::::::::::  solution

## Solution

```{r, answer=TRUE, purl=TRUE}
rna1 <- rna |>
select(gene, mouse, expression) |>
pivot_wider(names_from = mouse, values_from = expression)
rna1

rna1 |>
pivot_longer(names_to = "mouse_id", values_to = "counts", -gene)
```

:::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::  challenge

## Question

Extraire les gènes situés sur les chromosomes X et Y du data frame `rna` et
remodeler les données avec la variable `sex` en colonnes et la varibale `chromosome_name` en
lignes et l'expression moyenne des gènes localisés dans chaque chromosome comme valeurs,
comme dans le tableau suivant :

```{r, echo=FALSE, message=FALSE}
knitr::include_graphics("fig/Exercise_pivot_W.png")
```

You will need to summarise before reshaping!

:::::::::::::::  solution

## Solution

Calculons d'abord le niveau d'expression moyen des gènes des chromosomes X et Y pour les
échantillons mâles et femelles...

```{r}
 rna |>
  filter(chromosome_name == "Y" | chromosome_name == "X") |>
  group_by(sex, chromosome_name) |>
  summarise(mean = mean(expression))
```

Et pivotons le tableau au format large

```{r, answer=TRUE, purl=TRUE}
rna_1 <- rna |>
  filter(chromosome_name == "Y" | chromosome_name == "X") |>
  group_by(sex, chromosome_name) |>
  summarise(mean = mean(expression)) |>
  pivot_wider(names_from = sex,
              values_from = mean)

rna_1
```

Now take that data frame and transform it with `pivot_longer()` so
each row is a unique `chromosome_name` by `gender` combination.

```{r, answer=TRUE, purl=TRUE}
rna_1 |>
  pivot_longer(names_to = "gender",
               values_to = "mean",
               -chromosome_name)

```

:::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::  challenge

## Question

Utilisez l'ensemble de données `rna` pour créer une matrice d'expression où chaque ligne
représente les niveaux d'expression moyens des gènes et les colonnes représentent
les différents temps.

:::::::::::::::  solution

## Solution

Let's first calculate the mean expression by gene and by time

```{r}
rna |>
  group_by(gene, time) |>
  summarise(mean_exp = mean(expression))
```

avant d'utiliser la fonction `pivot_wider()`

```{r}
rna_time <- rna |>
  group_by(gene, time) |>
  summarise(mean_exp = mean(expression)) |>
  pivot_wider(names_from = time,
              values_from = mean_exp)
rna_time
```

Notice that this generates a tibble with some column names starting by a number.
Si nous voulions sélectionner la colonne correspondant aux points temporels,
nous ne pourrions pas utiliser directement les noms des colonnes... What happens when we select the column 4?

```{r}
rna |>
  group_by(gene, time) |>
  summarise(mean_exp = mean(expression)) |>
  pivot_wider(names_from = time,
              values_from = mean_exp) |>
  select(gene, 4)
```

To select the timepoint 4, we would have to quote the column name, with backticks "\\\`"

```{r}
rna |>
  group_by(gene, time) |>
  summarise(mean_exp = mean(expression)) |>
  pivot_wider(names_from = time,
              values_from = mean_exp) |>
  select(gene, `4`)
```

Une autre possibilité serait de renommer les colonnes,
en choisissant des noms qui ne commencent pas par un chiffre :

```{r}
rna |>
  group_by(gene, time) |>
  summarise(mean_exp = mean(expression)) |>
  pivot_wider(names_from = time,
              values_from = mean_exp) |>
  rename("time0" = `0`, "time4" = `4`, "time8" = `8`) |>
  select(gene, time4)
```

:::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::  challenge

## Question

Utilisez le data frame précédent contenant les niveaux d'expression moyens par temps et créez
une nouvelle colonne contenant les _fold-changes_ entre les temps 8 et 0, et les temps 8 et 4.
Convertissez ce tableau en un tableau au format long regroupant les _fold-changes_ calculés.

:::::::::::::::  solution

## Solution

À partir du tibble `rna_time` :

```{r}
rna_time
```

Calculer les _fold-changes_ :

```{r}
rna_time |>
  mutate(time_8_vs_0 = `8` / `0`, time_8_vs_4 = `8` / `4`)
```

Et utilisez la fonction `pivot_longer()` :

```{r}
rna_time |>
  mutate(time_8_vs_0 = `8` / `0`, time_8_vs_4 = `8` / `4`) |>
  pivot_longer(names_to = "comparisons",
               values_to = "Fold_changes",
               time_8_vs_0:time_8_vs_4)
```

:::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::::

## Jointures de tables

In many real life situations, data are spread across multiple tables.
Usually this occurs because different types of information are
collected from different sources.

Il peut être souhaitable que certaines analyses combinent les données de deux ou plusieurs tables
en un seul data frame basé sur une colonne commune
à toutes les tables.

The `dplyr` package provides a set of join functions for combining two
data frames based on matches within specified columns. Here, we
provide a short introduction to joins. For further reading, please
refer to the chapter about table
joins. The
Data Transformation Cheat
Sheet
also provides a short overview on table joins.

Nous allons illustrer la jointure en utilisant une petite table, `rna_mini` que
nous allons créer en extrayant de la table `rna` d'origine 3
colonnes et 10 lignes.

```{r}
rna_mini <- rna |>
   select(gene, sample, expression) |>
   head(10)
rna_mini
```

Le deuxième tableau, `annot1`, contient 2 colonnes, `gene` et
`gene_description`. Vous pouvez soit
[télécharger annot1.csv](https://carpentries-incubator.github.io/bioc-intro/data/annot1.csv)
en cliquant sur le lien puis en déplaçant le fichier dans le dossier `data/`, ou
vous pouvez utiliser le code R ci-dessous pour le télécharger directement dans le dossier `data`.

```{r, message=FALSE}
download.file(url = "https://carpentries-incubator.github.io/bioc-intro/data/annot1.csv",
              destfile = "data/annot1.csv")
annot1 <- read_csv(file = "data/annot1.csv")
annot1
```

We now want to join these two tables into a single one containing all
variables using the `full_join()` function from the `dplyr` package. The
function will automatically find the common variable to match columns
from the first and second table.  Dans ce cas, `gene` est la seule variable commune. De telles variables sont appelées clés. Les clés sont utilisées pour faire correspondre les
observations dans différentes tables.

```{r}
full_join(rna_mini, annot1)
```

En recherche, les gènes sont parfois només différemment.

La table `annot2` est exactement la même que `annot1` sauf que la variable
contenant les noms de gènes est nommée différemment. Encore une fois,
[téléchargez annot2.csv](https://carpentries-incubator.github.io/bioc-intro/data/annot2.csv)
vous-même et déplacez-le vers `data/ ` ou utilisez le code R ci-dessous.

```{r, message=FALSE}
download.file(url = "https://carpentries-incubator.github.io/bioc-intro/data/annot2.csv",
              destfile = "data/annot2.csv")
annot2 <- read_csv(file = "data/annot2.csv")
annot2
```

In case none of the variable names match, we can set manually the
variables to use for the matching.  These variables can be set using
the `by` argument, as shown below with `rna_mini` and `annot2` tables.

```{r}
full_join(rna_mini, annot2, by = c("gene" = "external_gene_name"))
```

Comme on peut le voir ci-dessus, le nom de variable de la première table est lors de la jointure.

:::::::::::::::::::::::::::::::::::::::  challenge

## Défi:

Téléchargez la table `annot3` en cliquant
[ici](https://carpentries-incubator.github.io/bioc-intro/data/annot3.csv)
et placez la table dans votre dossier `data`.  À l'aide de la fonction `full_join()`, joignez les tables `rna_mini` et `annot3`. What has happened for
genes _Klk6_, _mt-Tf_, _mt-Rnr1_, _mt-Tv_, _mt-Rnr2_, and _mt-Tl1_ ?

:::::::::::::::  solution

## Solution

```{r, message=FALSE}
annot3 <- read_csv("data/annot3.csv")
full_join(rna_mini, annot3)
```

Genes _Klk6_ is only present in `rna_mini`, while genes _mt-Tf_, _mt-Rnr1_, _mt-Tv_,
_mt-Rnr2_, and _mt-Tl1_ are only present in `annot3` table. Their respective values for the
variables of the table have been encoded as missing.

:::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::::

## Exportation des données

Now that you have learned how to use `dplyr` to extract information from
or summarise your raw data, you may want to export these new data sets to share
them with your collaborators or for archival.

Tout comme à la fonction `read_csv()` utilisée pour lire/importer les fichiers CSV dans R, il existe
une fonction `write_csv()` qui génère des fichiers CSV à partir de data frames.

Avant d'utiliser `write_csv()`, nous allons créer un nouveau dossier, `data_output`,
dans notre répertoire de travail, pour y sauvegarder nos nouveaux de données. Nous ne voulons pas
écrive les ensembles de données générés dans le même répertoire que nos données brutes.
C'est en effet une bonne pratique de les garder séparés. Le dossier `data` ne doit contenir que
les données brutes et non modifiées, et doit être laissé tel quel pour nous assurer que nous ne les supprimons ou modifions pas. En revanche, notre script générera le contenu du répertoire `data_output`, donc même si les fichiers qu'il contient sont supprimés, nous pourrons toujours
les regénérer.

Utilisons `write_csv()` pour sauvegarder la table `rna_wide` que nous avons créée précédemment.

```{r, purl=TRUE, eval=FALSE}
write_csv(rna_wide, file = "data_output/rna_wide.csv")
```

:::::::::::::::::::::::::::::::::::::::: keypoints

- Tabular data in R using the tidyverse meta-package

::::::::::::::::::::::::::::::::::::::::::::::::::
