---
source: Rmd
title: Data visualization
teaching: 60
exercises: 60
---

```{r loaddata_vis, echo=FALSE, purl=FALSE, message=FALSE}
if (!file.exists("data/rnaseq.csv"))
download.file(url = "https://github.com/carpentries-incubator/bioc-intro/raw/main/episodes/data/rnaseq.csv",
              destfile = "data/rnaseq.csv")
```

::::::::::::::::::::::::::::::::::::::: objectives

- Produire des _scatter plots_ (nuages de points), des _boxplots_ (boîtes à moustache), des _line plots_ (tracés linéaires), etc. en utilisant ggplot.
- Définir les paramètres universels des graphiques.
- Décrire ce qu'est le _faceting_ (facettage) et appliquez le _faceting_ dans ggplot.
- Modifiez les éléments esthétiques d'un tracé `ggplot` existant (y compris les étiquettes et la couleur des axes).
- Créer des graphiques complexes et personnalisés à prtir de données dans un _data frame_.

::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::: questions

- Visualization in R

::::::::::::::::::::::::::::::::::::::::::::::::::

```{r vis_setup, echo=FALSE}
rna <- read.csv("data/rnaseq.csv")
```

> Cet épisode est basé sur la leçon _Analyse des données et
> Visualisation dans R pour les écologistes_ de Data Carpentries.

## Data Visualization

We start by loading the required packages. **`ggplot2`** is included in
the **`tidyverse`** package.

```{r load-package, message=FALSE, purl=TRUE}
library("tidyverse")
```

If not still in the workspace, load the data we saved in the previous
lesson.

```{r load-data, eval=FALSE, purl=TRUE}
rna <- read.csv("data/rnaseq.csv")
```

The Data Visualization Cheat
Sheet
will cover the basics and more advanced features of `ggplot2` and will
help, in addition to serve as a reminder, getting an overview of the
many data representations available in the package. The following video
tutorials ([part 1](https://www.youtube.com/watch?v=h29g21z0a68) and
[2](https://www.youtube.com/watch?v=0m4yywqNPVY)) by Thomas Lin Pedersen
are also very instructive.

## Plotting with `ggplot2`

`ggplot2` est un package graphique qui simplifie la création de graphiques
complexes à partir de données dans un _data frame_. Il fournit une interface
de programmation pour spécifier les variables à représenter sur le graphique, comment elles sont représentées, ainsi que
les propriétés visuelles générales. The theoretical foundation that supports
the `ggplot2` is the _Grammar of Graphics_ (@Wilkinson:2005). En utilisant cette approche
, nous n'avons besoin que de changements minimes si les données sous-jacentes changent ou
si nous décidons de passer d'un _bar plot_ à un _scatter plot_, par exemple. Cela aide à
créer des graphiques de qualité professionnelle avec un minimum d'ajustements.

Il existe aussi un livre décrivant `ggplot2` (@ggplot2book) qui en fournit un bon aperçu, mais il est obsolète. The 3rd edition is in preparation and will
be [freely available online](https://ggplot2-book.org/). The `ggplot2`
webpage ([https://ggplot2.tidyverse.org](https://ggplot2.tidyverse.org)) provides ample documentation.

`ggplot2` fonctionne avec des données au format « long », c'est-à-dire une colonne pour
chaque variable et une ligne pour chaque observation. Des données bien structurées
vous feront gagner beaucoup de temps lors de la création de figures avec `ggplot2`.

Les graphiques ggplot sont construits étape par étape en ajoutant de nouveaux éléments appelés _couches_. L'ajout progressif de
couches permet une grande flexibilité et une
personnalisation des graphiques.

> The idea behind the Grammar of Graphics it is that you can build every
> graph from the same 3 components: (1) a data set, (2) a coordinate system,
> and (3) geoms — i.e. visual marks that represent data points \\[^three\\\_comp\\\_ggplot2]

[^three_comp_ggplot2]: Source : [Data Visualization Cheat Sheet](https://raw.githubusercontent.com/rstudio/cheatsheets/main/data-visualization.pdf).

Pour construire un ggplot, nous utiliserons le modèle de base suivant qui peut être
utilisé pour différents types de graphiques :

```
ggplot(data = <DATA>, mapping = aes(<MAPPINGS>)) +  <GEOM_FUNCTION>()
```

- use the `ggplot()` function and bind the plot to a specific **data
 frame** using the `data` argument

```{r, eval=FALSE}
ggplot(data = rna)
```

- define a **mapping** (using the aesthetic (`aes`) function), by
 selecting the variables to be plotted and specifying how to present
 them in the graph, e.g. as x/y positions or characteristics such as
 size, shape, color, etc.

```{r, eval=FALSE}
ggplot(data = rna, mapping = aes(x = expression))
```

- add '**geoms**' - geometries, or graphical representations of the
 data in the plot (points, lines, bars). `ggplot2` offers many
 different geoms; we will use some common ones today, including:

 ```
 \* `geom_point()` for scatter plots, dot plots, etc.
    \* `geom_histogram()` for histograms
    \* `geom_boxplot()` for, well, boxplots! \* `geom_line()` for trend lines, time series, etc.
 ```

Pour ajouter un _geom_ au graphique, utilisez l'opérateur `+`. Let's use
`geom_histogram()` first:

```{r first-ggplot, cache=FALSE, purl=TRUE}
ggplot(data = rna, mapping = aes(x = expression)) +
  geom_histogram()
```

Le symbole `+` dans le package `ggplot2` est particulièrement utile car il
vous permet de modifier les objets `ggplot` existants. Cela signifie que vous pouvez
facilement configurer des modèles de graphique et explorer facilement différents types de
graphiques. En procédant de la sorte, le graphique obtenu précédemment peut également être généré avec un code comme celui-ci :

```{r, eval=FALSE, purl=TRUE}
# Assign plot to a variable
rna_plot <- ggplot(data = rna,
                   mapping = aes(x = expression))

# Draw the plot
rna_plot + geom_histogram()
```

:::::::::::::::::::::::::::::::::::::::  challenge

## Challenge

Vous avez probablement remarqué un message automatique qui apparaît lorsqu'on trace un histogramme :

```{r, echo=FALSE, fig.show="hide"}
ggplot(rna, aes(x = expression)) +
  geom_histogram()
```

Définissez un _mapping_ (en utilisant la fonction esthétique (`aes`)), qui consiste à: (1) sélectionner les variables du _data frame_ à réprésenter et (2) les lier à des caractéristiques du graphique comme les coordonnées x ou y, ou encore la taille, la couleur, la forme, etc.

:::::::::::::::  solution

## Solution

```{r, purl=TRUE}
# change bins
ggplot(rna, aes(x = expression)) +
    geom_histogram(bins = 15)

# change binwidth
ggplot(rna, aes(x = expression)) +
    geom_histogram(binwidth = 2000)
```

:::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::::

Nous pouvons observer ici que les données présentent un _right skew_ (asymétrie vers la droite). Nous pouvons appliquer la transformation
log2 pour obtenir une distribution plus symétrique. Notez que nous
ajoutons ici une petite valeur constante (`+1`) pour éviter que `-Inf` soit renvoyée pour des expressions égales à 0.

```{r log-transfo, cache=FALSE, purl=TRUE}
rna <- rna |>
  mutate(expression_log = log2(expression + 1))
```

If we now draw the histogram of the log2-transformed expressions, the
distribution is indeed closer to a normal distribution.

```{r second-ggplot, cache=FALSE, purl=TRUE}
ggplot(rna, aes(x = expression_log)) + geom_histogram()
```

From now on we will work on the log-transformed expression values.

:::::::::::::::::::::::::::::::::::::::  challenge

## Challenge

Une autre façon de visualiser cette transformation, plutôt que de transformer les données elles-mêmes, est de garder les données inchangées mais de choisir une autre échelle des observations. Par exemple, il peut être intéressant de changer l'échelle
de l'axe pour mieux répartir les observations dans le graphique. Changer l'échelle des axes se fait de la même manière que
pour ajouter/modifier d'autres composants (c'est-à-dire en ajoutant progressivement des commandes). Essayez de modifier le graphique précédent de la manière suivante:

- Represent the un-transformed expression on the log10 scale; see
 `scale_x_log10()`. Comparer le résultat avec le graphique précédent. Why do you
 now have warning messages appearing?

:::::::::::::::  solution

## Solution

```{r, eval=TRUE, purl=TRUE, echo=TRUE}
ggplot(data = rna,mapping = aes(x = expression))+
  geom_histogram() +
  scale_x_log10()
```

:::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::::

**Notes**

- Anything you put in the `ggplot()` function can be seen by any geom
 layers that you add (i.e., these are global plot settings). This
 includes the x- and y-axis mapping you set up in `aes()`.
- You can also specify mappings for a given geom independently of the
 mappings defined globally in the `ggplot()` function.
- The `+` sign used to add new layers must be placed at the end of the
 line containing the _previous_ layer. If, instead, the `+` sign is
 added at the beginning of the line containing the new layer,
 `ggplot2` will not add the new layer and will return an error
 message.

```{r, eval=FALSE}
# This is the correct syntax for adding layers
rna_plot +
  geom_histogram()

# This will not add the new layer and will return an error message
rna_plot
  + geom_histogram()
```

## Construire vos graphiques de manière itérative

Nous allons maintenant dessiner un _scatter plot_ avec deux variables continues et la fonction `geom_point()`. Ce graphique représentera les `log2 fold changes` (ratio de valeurs convertis en `log`) des expressions, entre le temps 8 et le temps 0 d'une part, et entre le temps 4 et le temps 0 d'autre part.
Pour ce faire, nous devons d'abord calculer les moyennes des valeurs d'expression
transformées en log par gène et par temps, puis les _log fold changes_ souhaités. Notez que nous incluons également ici le biotype du gène, que nous utiliserons plus tard pour représenter les gènes. Nous enregistrerons
les _log fold changes_ dans un nouveau _data frame_ appelé `rna_fc.`

```{r rna_fc, cache=FALSE, purl=TRUE}
rna_fc <- rna |> select(gene, time,
                         gene_biotype, expression_log) |>
  group_by(gene, time, gene_biotype) |>
  summarize(mean_exp = mean(expression_log)) |>
  pivot_wider(names_from = time,
              values_from = mean_exp) |>
  mutate(time_8_vs_0 = `8` - `0`, time_4_vs_0 = `4` - `0`)

```

Nous pouvons ensuite construire un ggplot avec le jeu de données nouvellement créé `rna_fc`.
Construire des graphiques avec `ggplot2` est généralement un processus itératif. Nous
commençons par définir le jeu de données que nous allons utiliser, tracer les axes et choisir une
_geom_ :

```{r create-ggplot-object, cache=FALSE, purl=TRUE}
ggplot(data = rna_fc, mapping = aes(x = time_4_vs_0, y = time_8_vs_0)) +
  geom_point()
```

Ensuite, nous commençons à modifier ce graphique pour en extraire davantage d’informations.
Par exemple, nous pouvons ajouter de la transparence (« alpha ») pour éviter la surcharge du graphique:

```{r adding-transparency, cache=FALSE, purl=TRUE}
ggplot(data = rna_fc, mapping = aes(x = time_4_vs_0, y = time_8_vs_0)) +
  geom_point(alpha = 0.3)
```

We can also add colors for all the points:

```{r adding-colors, cache=FALSE, purl=TRUE}
ggplot(data = rna_fc, mapping = aes(x = time_4_vs_0, y = time_8_vs_0)) +
  geom_point(alpha = 0.3, color = "blue")
```

Ou pour colorer différemment chaque gène du graphique, vous pouvez utiliser un vecteur comme
input dans l'argument **color**. `ggplot2` assignera une couleur
différente à chaques valeurs dans le vecteur. Voici un
exemple où nous colorons avec la variable `gene_biotype` :

```{r color-by-gene_biotype1, cache=FALSE, purl=TRUE}
ggplot(data = rna_fc, mapping = aes(x = time_4_vs_0, y = time_8_vs_0)) +
  geom_point(alpha = 0.3, aes(color = gene_biotype))

```

Nous pouvons également spécifier les couleurs directement à l'intérieur du mapping fourni dans
la fonction `ggplot()`. Cela sera visible par toutes les couches de _geom_ et le mapping sera déterminé par les axes x et y définis dans `aes()`.

```{r color-by-gene_biotype2, cache=FALSE, purl=TRUE}
ggplot(data = rna_fc, mapping = aes(x = time_4_vs_0, y = time_8_vs_0,
                                color = gene_biotype)) +
  geom_point(alpha = 0.3)
```

Finally, we could also add a diagonal line with the `geom_abline()`
function:

```{r adding-diag, cache=FALSE, purl=TRUE}
ggplot(data = rna_fc, mapping = aes(x = time_4_vs_0, y = time_8_vs_0,
                                color = gene_biotype)) +
  geom_point(alpha = 0.3) +
  geom_abline(intercept = 0)
```

Notez que nous pouvons remplacer `geom_point` par `geom_jitter` et les couleurs seront toujours déterminées par `gene_biotype`.

```{r color-by-gene_biotype3, cache=FALSE, purl=TRUE}
ggplot(data = rna_fc, mapping = aes(x = time_4_vs_0, y = time_8_vs_0,
                                color = gene_biotype)) +
  geom_jitter(alpha = 0.3) +
  geom_abline(intercept = 0)
```

```{r, echo=FALSE, message=FALSE}
library("hexbin")
```

:::::::::::::::::::::::::::::::::::::::  challenge

## Challenge

Les _scatter plots_ peuvent être des outils d’exploration utiles pour de petits jeux de données. Pour les jeux de données
avec un grand nombre d'observations, tels que le jeu de données `rna_fc`
, l'accumulation de points peut surcharger le graphique, ce qui constitue une limitation des _scatter plots_.
Une stratégie possible dans de tels cas consiste à utiliser le regroupement hexagonal d'observations. Dans ce cas, l’espace du graphique est divisé en hexagones. Chaque
hexagone se voit attribuer une couleur en fonction du nombre d'observations qui se trouvent à l'intérieur.

- To use hexagonal binning in `ggplot2`, first install the R package
 `hexbin` from CRAN and load it.

- Then use the `geom_hex()` function to produce the hexbin figure.

- What are the relative strengths and weaknesses of a hexagonal bin
 plot compared to a scatter plot? Examine the above scatter plot
 and compare it with the hexagonal bin plot that you created.

:::::::::::::::  solution

## Solution

```{r, eval=FALSE, purl=TRUE}
install.packages("hexbin")
```

```{r, purl=TRUE}
library("hexbin")

ggplot(data = rna_fc, mapping = aes(x = time_4_vs_0, y = time_8_vs_0)) +
  geom_hex() +
  geom_abline(intercept = 0)

```

:::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::  challenge

## Challenge

Utilisez ce que vous venez d'apprendre pour créer un _scatter plot_ de la variable `expression_log`  en fonction de  la variable `sample`, à partir du jeu de données `rna`, avec l'heure affichée dans
différentes couleurs. Is this a good way to show this type of data?

:::::::::::::::  solution

## Solution

```{r, eval=TRUE, purl=TRUE}
ggplot(data = rna, mapping = aes(y = expression_log, x = sample)) +
    geom_point(aes(color = time))
```

:::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::::

## _Boxplot_ (boîte à moustaches)

Nous pouvons utiliser des _boxplots_ pour visualiser la distribution des expressions géniques au sein de chaque échantillon :

```{r boxplot, cache=FALSE, purl=TRUE}
ggplot(data = rna,
         mapping = aes(y = expression_log, x = sample)) +
  geom_boxplot()
```

En ajoutant des points au _boxplot_, on peut avoir une meilleure idée du nombre de
mesures et de leur distribution :

```{r boxplot-with-points, cache=FALSE, purl=TRUE}
ggplot(data = rna,
         mapping = aes(y = expression_log, x = sample)) +
  geom_jitter(alpha = 0.2, color = "tomato") +
  geom_boxplot(alpha = 0)
```

:::::::::::::::::::::::::::::::::::::::  challenge

## Challenge

Avez-vous remarqué que la couche _boxplot_ se trouve devant la couche _jitter_ ? Que devez-vous
modifier dans le code pour placer le _boxplot_ sous les points ?

:::::::::::::::  solution

## Solution

Nous devrions inverser l'ordre de ces deux _geom_:

```{r boxplot-with-points2, cache=FALSE, purl=TRUE}
ggplot(data = rna,
         mapping = aes(y = expression_log, x = sample)) +
  geom_boxplot(alpha = 0) +
  geom_jitter(alpha = 0.2, color = "tomato")
```

:::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::::

Vous remarquerez peut-être que les valeurs sur l'axe des x ne sont toujours pas lisibles correctement. Modifions l'orientation des étiquettes et ajustons-les
verticalement et horizontalement afin qu'elles ne se chvauchent pas. Vous pouvez utiliser un angle de
90 degrés ou expérimenter pour trouver l'angle approprié pour
des étiquettes orientées en diagonale :

```{r boxplot-xaxis-rotated, cache=FALSE, purl=TRUE}
ggplot(data = rna,
         mapping = aes(y = expression_log, x = sample)) +
  geom_jitter(alpha = 0.2, color = "tomato") +
  geom_boxplot(alpha = 0) +
  theme(axis.text.x = element_text(angle = 90,  hjust = 0.5, vjust = 0.5))
```

:::::::::::::::::::::::::::::::::::::::  challenge

## Challenge

Ajoutez de la couleur aux points de données sur votre _boxplot_ en fonction de la durée
de l'infection (« time »).

_Hint:_ Check the class for `time`. Envisagez de changer la classe de
`time` d'entier à _factor_ directement dans le mapping ggplot. Why does
this change how R makes the graph?

:::::::::::::::  solution

## Solution

```{r boxplot-color-time, cache=FALSE, purl=TRUE}
# time as integer
ggplot(data = rna,
         mapping = aes(y = expression_log,
                       x = sample)) +
  geom_jitter(alpha = 0.2, aes(color = time)) +
  geom_boxplot(alpha = 0) +
  theme(axis.text.x = element_text(angle = 90,  hjust = 0.5, vjust = 0.5))

# time as factor
ggplot(data = rna,
         mapping = aes(y = expression_log,
                       x = sample)) +
  geom_jitter(alpha = 0.2, aes(color = as.factor(time))) +
  geom_boxplot(alpha = 0) +
  theme(axis.text.x = element_text(angle = 90,  hjust = 0.5, vjust = 0.5))
```

:::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::  challenge

## Challenge

Boxplots are useful summaries, but hide the _shape_ of the
distribution. Par exemple, si la distribution est bi-modale, nous ne le verrions
pas dans un _boxplot_. Une alternative au _boxplot_ est le _violin plot_ (graphiques en violon)
, où la forme de la densité de points est dessinée.

- Remplacez la _box plot_ par un _violin plot_ ; voir `geom_violin()`. Fill
 in the violins according to the time with the argument `fill`.

:::::::::::::::  solution

## Solution

```{r, eval=TRUE, echo=TRUE, cache=FALSE, purl=TRUE}
ggplot(data = rna,
         mapping = aes(y = expression_log, x = sample)) +
  geom_violin(aes(fill = as.factor(time))) +
  theme(axis.text.x = element_text(angle = 90,  hjust = 0.5, vjust = 0.5))
```

:::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::  challenge

## Challenge

- Modifiez le _violin plot_ pour lier la couleur de remplissage des violons à la variable "sex".

:::::::::::::::  solution

## Solution

```{r, eval=TRUE, echo=TRUE, cache=FALSE, purl=TRUE}
ggplot(data = rna,
         mapping = aes(y = expression_log, x = sample)) +
  geom_violin(aes(fill = sex)) +
  theme(axis.text.x = element_text(angle = 90,  hjust = 0.5, vjust = 0.5))
```

:::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::::

## _Line plots_ (graphiques linéaires)

Calculons l'expression moyenne par durée de l'infection pour
les 10 gènes ayant les _log fold changes_ comparant le temps 8 au
temps 0 les plus élevés. Tout d'abord, nous devons sélectionner les gènes et créer un sous-ensemble de `rna`
appelé `sub_rna` contenant les 10 gènes sélectionnés, puis nous devons regrouper
les données et calculer l'expression moyenne des gènes dans chaque groupe :

```{r, purl=TRUE}
rna_fc <- rna_fc |> arrange(desc(time_8_vs_0))

genes_selected <- rna_fc$gene[1:10]

sub_rna <- rna |>
    filter(gene %in% genes_selected)

mean_exp_by_time <- sub_rna |>
  group_by(gene,time) |>
    summarize(mean_exp = mean(expression_log))

mean_exp_by_time
```

Nous pouvons construire le _line plot_ avec la durée de l'infection sur l'axe des x
et l'expression moyenne sur l'axe des y :

```{r first-time-series, purl=TRUE}
ggplot(data = mean_exp_by_time, mapping = aes(x = time, y = mean_exp)) +
  geom_line()
```

Malheureusement, cela ne fonctionne pas car nous avons représenté ensemble les données de tous les gènes
. We need to tell ggplot to draw a line for each gene by
modifying the aesthetic function to include `group = gene`:

```{r time-series-by-gene, purl=TRUE}
ggplot(data = mean_exp_by_time,
       mapping = aes(x = time, y = mean_exp, group = gene)) +
  geom_line()
```

Nous pourrons distinguer les gènes dans le graphique si nous ajoutons des couleurs (l'utilisation de
`color` regroupe également automatiquement les données) :

```{r time-series-with-colors, purl=TRUE}
ggplot(data = mean_exp_by_time,
       mapping = aes(x = time, y = mean_exp, color = gene)) +
  geom_line()
```

## _Faceting_ (diviser en facettes)

`ggplot2` has a special technique called _faceting_ that allows the user
to split one plot into multiple (sub) plots based on a factor included
in the dataset. Ces différents sous-graphiques héritent des mêmes propriétés
(limites des axes, graduations, ...) to facilitate their direct comparison. Nous allons
l'utiliser pour créer un _line plot_ en fonction du temps pour chaque gène :

```{r first-facet, purl=TRUE}
ggplot(data = mean_exp_by_time,
       mapping = aes(x = time, y = mean_exp)) + geom_line() +
  facet_wrap(~ gene)
```

Ici, les axes x et y ont la même échelle pour tous les sous-graphiques. You
can change this default behavior by modifying `scales` in order to allow
a free scale for the y-axis:

```{r first-facet-scales, purl=TRUE}
ggplot(data = mean_exp_by_time,
       mapping = aes(x = time, y = mean_exp)) +
  geom_line() +
  facet_wrap(~ gene, scales = "free_y")
```

Nous aimerions maintenant diviser la ligne dans chaque graphiques selon le sexe des souris.
Pour ce faire, nous devons calculer l'expression moyenne dans le _data frame_
regroupé par "gene", "time" et "sex" :

```{r data-facet-by-gene-and-sex, purl=TRUE}
mean_exp_by_time_sex <- sub_rna |>
  group_by(gene, time, sex) |>
    summarize(mean_exp = mean(expression_log))

mean_exp_by_time_sex
```

Nous pouvons maintenant créer le graphique à facettes. Nous ajoutons encore de l'information en divisant le _line plot_ par sexe en y associant des couleurs (au sein d'un seul graphique) :

```{r facet-by-gene-and-sex, cache=FALSE, purl=TRUE}
ggplot(data = mean_exp_by_time_sex,
       mapping = aes(x = time, y = mean_exp, color = sex)) +
  geom_line() +
  facet_wrap(~ gene, scales = "free_y")
```

Généralement, les graphiques sur fond blanc sont plus lisibles une fois imprimés. We
can set the background to white using the function `theme_bw()`.
Additionally, we can remove the grid:

```{r facet-by-gene-and-sex-white-bg, cache=FALSE, purl=TRUE}
ggplot(data = mean_exp_by_time_sex,
       mapping = aes(x = time, y = mean_exp, color = sex)) +
  geom_line() +
  facet_wrap(~ gene, scales = "free_y") +
  theme_bw() +
  theme(panel.grid = element_blank())
```

:::::::::::::::::::::::::::::::::::::::  challenge

## Challenge

Use what you just learned to create a plot that depicts how the
average expression of each chromosome changes through the duration of
infection.

:::::::::::::::  solution

## Solution

```{r mean-exp-chromosome-time-series, purl=TRUE}
mean_exp_by_chromosome <- rna |>
  group_by(chromosome_name, time) |>
  summarize(mean_exp = mean(expression_log))

ggplot(data = mean_exp_by_chromosome, mapping = aes(x = time,
                                y = mean_exp)) +
  geom_line() +
  facet_wrap(~ chromosome_name, scales = "free_y")
```

:::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::::

Le _geom_ `facet_wrap` extrait les graphiques dans un nombre quelconque de
dimensions pour leur permettre de s'adapter joliment à une seule page. De plus, le _geom_ `facet_grid` permet de spécifier explicitement comment les graphiques doivent être disposés par la notation en formule (`rows ~ columns`; un `.` peut-être utilisé comme un raccourci pour indiquer une seule ligne ou colonne).

Let's modify the previous plot to compare how the mean gene expression
of males and females has changed through time:

```{r mean-exp-time-facet-sex-rows, purl=TRUE}
# One column, facet by rows
ggplot(data = mean_exp_by_time_sex,
       mapping = aes(x = time, y = mean_exp, color = gene)) +
  geom_line() +
  facet_grid(sex ~ .)
```

```{r mean-exp-time-facet-sex-columns, purl=TRUE}
# One row, facet by column
ggplot(data = mean_exp_by_time_sex,
       mapping = aes(x = time, y = mean_exp, color = gene)) +
  geom_line() +
  facet_grid(. ~ sex)
```

## `ggplot2` themes

En plus de `theme_bw()`, qui change l'arrière-plan du graphique en blanc,
`ggplot2` contient plusieurs autres thèmes qui peuvent être utiles pour
changer rapidement l'apparence de votre visualisation. The complete list of themes is
available at [https://ggplot2.tidyverse.org/reference/ggtheme.html](https://ggplot2.tidyverse.org/reference/ggtheme.html).
`theme_minimal()` et `theme_light()` sont populaires, et `theme_void()`
peut être utile comme point de départ pour créer un nouveau thème à la main.

The [ggthemes](https://jrnold.github.io/ggthemes/reference/index.html)
package provides a wide variety of options (including an Excel 2003
theme). The ggplot2 provides a list of
packages that extend the capabilities of `ggplot2`, including additional
themes.

## Customisation

Revenons au graphique à facettes de l'expression moyenne par temps et gène,
colorée par sexe.

Take a look at the ggplot2,
and think of ways you could improve the plot.

Now, we can change names of axes to something more informative than
'time' and 'mean\_exp', and add a title to the figure:

```{r mean_exp-time-with-right-labels, cache=FALSE, purl=TRUE}
ggplot(data = mean_exp_by_time_sex,
       mapping = aes(x = time, y = mean_exp, color = sex)) +
  geom_line() +
  facet_wrap(~ gene, scales = "free_y") +
  theme_bw() +
  theme(panel.grid = element_blank()) +
  labs(title = "Mean gene expression by duration of the infection",
       x = "Duration of the infection (in days)",
       y = "Mean gene expression")
```

The axes have more informative names, but their readability can be
improved by increasing the font size:

```{r mean_exp-time-with-right-labels-xfont-size, cache=FALSE, purl=TRUE}
ggplot(data = mean_exp_by_time_sex,
       mapping = aes(x = time, y = mean_exp, color = sex)) +
  geom_line() +
  facet_wrap(~ gene, scales = "free_y") +
  theme_bw() +
  theme(panel.grid = element_blank()) +
  labs(title = "Mean gene expression by duration of the infection",
       x = "Duration of the infection (in days)",
       y = "Mean gene expression")  +
  theme(text = element_text(size = 16))
```

Notez qu'il est également possible de changer les polices de vos graphiques. If you
are on Windows, you may have to install the .

We can further customize the color of x- and y-axis text, the color of
the grid, etc. Nous pouvons aussi par exemple déplacer la légende vers le haut en
mettant `legend.position` égal à `"top"`.

```{r mean_exp-time-with-theme, cache=FALSE, purl=TRUE}
ggplot(data = mean_exp_by_time_sex,
       mapping = aes(x = time, y = mean_exp, color = sex)) +
  geom_line() +
  facet_wrap(~ gene, scales = "free_y") +
  theme_bw() +
  theme(panel.grid = element_blank()) +
  labs(title = "Mean gene expression by duration of the infection",
       x = "Duration of the infection (in days)",
       y = "Mean gene expression")  +
  theme(text = element_text(size = 16),
        axis.text.x = element_text(colour = "royalblue4", size = 12),
        axis.text.y = element_text(colour = "royalblue4", size = 12),
        panel.grid = element_line(colour="lightsteelblue1"),
        legend.position = "top")
```

Si vous aimez les modifications que vous avez créées au thème par défaut, vous pouvez
les enregistrer en tant qu'objet pour pouvoir les appliquer facilement à d'autres
graphiques par la suite. Here is an example with the histogram we have
previously created.

```{r mean_exp-time-with-right-labels-xfont, cache=FALSE, purl=TRUE}
blue_theme <- theme(axis.text.x = element_text(colour = "royalblue4",
                                               size = 12),
                    axis.text.y = element_text(colour = "royalblue4",
                                               size = 12),
                    text = element_text(size = 16),
                    panel.grid = element_line(colour="lightsteelblue1"))

ggplot(rna, aes(x = expression_log)) +
  geom_histogram(bins = 20) +
    blue_theme
```

:::::::::::::::::::::::::::::::::::::::  challenge

## Challenge

Considérant toutes ces nouvelles informations, pourriez-vous consacrer encore cinq minutes, soit pour améliorer l'un des graphiques générés dans cet exercice, soit
pour créer votre propre graphique ? Use the RStudio ggplot2
for inspiration. Here are some ideas:

- See if you can change the thickness of the lines.
- Can you find a way to change the name of the legend? What about
 its labels? (hint: look for a ggplot function starting with
 `scale_`)
- Try using a different color palette or manually specifying the
 colors for the lines (see
 [http://www.cookbook-r.com/Graphs/Colors\_(ggplot2)/](https://www.cookbook-r.com/Graphs/Colors_\\\(ggplot2\\\)/)).

:::::::::::::::  solution

## Solution

Par exemple, sur la base de ce graphique :

```{r, purl=TRUE}
ggplot(data = mean_exp_by_time_sex,
       mapping = aes(x = time, y = mean_exp, color = sex)) +
  geom_line() +
  facet_wrap(~ gene, scales = "free_y") +
  theme_bw() +
  theme(panel.grid = element_blank())
```

We can customize it the following ways:

```{r, purl=TRUE}
# change the thickness of the lines
ggplot(data = mean_exp_by_time_sex,
       mapping = aes(x = time, y = mean_exp, color = sex)) +
  geom_line(size=1.5) +
  facet_wrap(~ gene, scales = "free_y") +
  theme_bw() +
  theme(panel.grid = element_blank())

# change the name of the legend and the labels
ggplot(data = mean_exp_by_time_sex,
       mapping = aes(x = time, y = mean_exp, color = sex)) +
  geom_line() +
  facet_wrap(~ gene, scales = "free_y") +
  theme_bw() +
  theme(panel.grid = element_blank()) +
  scale_color_discrete(name = "Gender", labels = c("F", "M"))

# using a different color palette
ggplot(data = mean_exp_by_time_sex,
       mapping = aes(x = time, y = mean_exp, color = sex)) +
  geom_line() +
  facet_wrap(~ gene, scales = "free_y") +
  theme_bw() +
  theme(panel.grid = element_blank()) +
  scale_color_brewer(name = "Gender", labels = c("F", "M"), palette = "Dark2")

# manually specifying the colors
ggplot(data = mean_exp_by_time_sex,
       mapping = aes(x = time, y = mean_exp, color = sex)) +
  geom_line() +
  facet_wrap(~ gene, scales = "free_y") +
  theme_bw() +
  theme(panel.grid = element_blank()) +
  scale_color_manual(name = "Gender",  labels = c("F", "M"),
                     values = c("royalblue", "deeppink"))

```

:::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::::

## Composer des graphques

Le _faceting_ est un super outil pour diviser un graphique en plusieurs sous-graphiques, mais parfois on aimerait plutôt obtenir une figure unique qui contient plusieurs graphiques indépendants, i.e. des graphiques basés sur différentes variables ou même différents _data frames_.

Commençons par créer les deux graphiques que nous souhaitons disposer l'un à côté de l'autre.

The first graph counts the number of unique genes per chromosome. We
first need to reorder the levels of `chromosome_name` and filter the
unique genes per chromosome. We also change the scale of the y-axis to a
log10 scale for better readability.

```{r sub1, purl=TRUE}
rna$chromosome_name <- factor(rna$chromosome_name,
                               levels = c(1:19,"X","Y"))

count_gene_chromosome <- rna |>
  select(chromosome_name, gene) |>
  distinct() |> ggplot() +
  geom_bar(aes(x = chromosome_name), fill = "seagreen",
           position = "dodge", stat = "count") +
  labs(y = "log10(n genes)", x = "chromosome") +
  scale_y_log10()

count_gene_chromosome
```

Ci-dessous, nous supprimons également complètement la légende en mettant
`legend.position` à`"none"`.

```{r sub2, purl=TRUE}
exp_boxplot_sex <- ggplot(rna, aes(y=expression_log, x = as.factor(time),
                 color=sex)) +
   geom_boxplot(alpha = 0) +
  labs(y = "Mean gene exp",
       x = "time") + theme(legend.position = "none")

exp_boxplot_sex
```

Le package [**patchwork**](https://github.com/thomasp85/patchwork)
fournit une approche élégante pour combiner des figures en utilisant le « + » pour
disposer les figures (typiquement côte à côte). More specifically the `|`
explicitly arranges them side by side and `/` stacks them on top of each
other.

```{r install-patchwork, message=FALSE, eval=FALSE, purl=TRUE}
install.packages("patchwork")
```

```{r patchworkplot1, purl=TRUE}
library("patchwork")
count_gene_chromosome + exp_boxplot_sex
## or count_gene_chromosome | exp_boxplot_sex
```

```{r patchwork2, purl=TRUE}
count_gene_chromosome / exp_boxplot_sex
```

Nous pouvons encore améliorer l'aspect de la composition finale avec
`plot_layout` pour créer des mises en page plus complexes :

```{r patchwork3, purl=TRUE}
count_gene_chromosome + exp_boxplot_sex + plot_layout(ncol = 1)
```

```{r patchwork4, purl=TRUE}
count_gene_chromosome +
 (count_gene_chromosome + exp_boxplot_sex) +
 exp_boxplot_sex +
 plot_layout(ncol = 1)
```

Le dernier graphique peut également être créé à l'aide des opérateurs de composition `|` et `/`:

```{r patchwork5, purl=TRUE}
count_gene_chromosome /
 (count_gene_chromosome | exp_boxplot_sex) /
 exp_boxplot_sex
```

Learn more about `patchwork` on its
[webpage](https://patchwork.data-imaginist.com/) or in this
[video](https://www.youtube.com/watch?v=0m4yywqNPVY).

Une autre possibilité est le package **`gridExtra`** qui permet de combiner
des ggplots séparés en une seule figure en utilisant `grid.arrange()` :

```{r install-gridextra, message=FALSE, eval=FALSE, purl=TRUE}
install.packages("gridExtra")
```

```{r gridarrange-example, message=FALSE, fig.width=10, purl=TRUE}
library("gridExtra")
grid.arrange(count_gene_chromosome, exp_boxplot_sex, ncol = 2)
```

In addition to the `ncol` and `nrow` arguments, used to make simple
arrangements, there are tools for constructing more complex
layouts.

## Exporter des graphiques

Après avoir créé votre graphique, vous pouvez le sauvegarder dans un fichier, avec votre format préféré. L'onglet **Export** dans le volet **Plot** de RStudio enregistrera vos graphiques, mais néanmoins à basse résolution, ce qui pourrait compromettre leur publication dans de nombreuses revues et qui ne s'adaptera pas bien aux posters de grande taille.

Utilisez plutôt la fonction `ggsave()`, qui vous permet de modifier facilement la dimension
et la résolution de votre tracé en modifiant les arguments
appropriés (`width`, `height` et `dpi` ).

Make sure you have the `fig_output/` folder in your working directory.

```{r ggsave-example, eval=FALSE, purl=TRUE}
my_plot <- ggplot(data = mean_exp_by_time_sex,
       mapping = aes(x = time, y = mean_exp, color = sex)) +
  geom_line() +
  facet_wrap(~ gene, scales = "free_y") +
  labs(title = "Mean gene expression by duration of the infection",
         x = "Duration of the infection (in days)",
         y = "Mean gene expression") +
  guides(color=guide_legend(title="Gender")) +
  theme_bw() +
  theme(axis.text.x = element_text(colour = "royalblue4", size = 12),
        axis.text.y = element_text(colour = "royalblue4", size = 12),
        text = element_text(size = 16),
        panel.grid = element_line(colour="lightsteelblue1"),
        legend.position = "top")
ggsave("fig_output/mean_exp_by_time_sex.png", my_plot, width = 15,
       height = 10)

# This also works for grid.arrange() plots
combo_plot <- grid.arrange(count_gene_chromosome, exp_boxplot_sex,
                           ncol = 2, widths = c(4, 6))
ggsave("fig_output/combo_plot_chromosome_sex.png", combo_plot,
       width = 10, dpi = 300)
```

Remarque : Les paramètres "width" et "height" déterminent également la taille de la police dans le graphique enregistré.

```{r final-challenge, eval=FALSE, purl=TRUE, echo=FALSE}
### Final plotting challenge:
##  With all of this information in hand, please take another five
##  minutes to either improve one of the plots generated in this
##  exercise or create a beautiful graph of your own. Use the RStudio
##  ggplot2 cheat sheet for inspiration:
##  https://raw.githubusercontent.com/rstudio/cheatsheets/main/data-visualization.pdf
```

## Other packages for visualisation

`ggplot2` is a very powerful package that fits very nicely in our _tidy
data_ and _tidy tools_ pipeline. Il existe cependant d'autres packages de visualisation
dans R qu'il est intéressant de connaître également.

### _Base graphics_

The default graphics system that comes with R, often called _base R
graphics_ is simple and fast. It is based on the _painter's or canvas
model_, where different output are directly overlaid on top of each
other (see figure @ref(fig:paintermodel)). C'est une différence fondamentale
avec `ggplot2` (et avec `lattice`, décrit ci-dessous), qui
renvoie des objets dédiés, qui sont visualisés à l'écran ou dans un fichier, et
qui peuvent même être modifiés.

```{r paintermodel, fig.width=12, fig.height=4, fig.cap="Successive layers added on top of each other."}
par(mfrow = c(1, 3))
plot(1:20, main = "First layer, produced with plot(1:20)")

plot(1:20, main = "A horizontal red line, added with abline(h = 10)")
abline(h = 10, col = "red")

plot(1:20, main = "A rectangle, added with rect(5, 5, 15, 15)")
abline(h = 10, col = "red")
rect(5, 5, 15, 15, lwd = 3)
```

Another main difference is that base graphics' plotting function try to
do _the right_ thing based on their input type, i.e. they will adapt
their behaviour based on the class of their input. C'est encore une fois très
différent de ce que nous avons avec `ggplot2`, qui n'accepte que les _data frames_
en entrée, et qui nécessite que les graphiques soient construits petit à petit.

```{r plotmethod, fig.width=8, fig.height=8, fig.cap="Plotting boxplots (top) and histograms (bottom) vectors (left) or a matrices (right)."}
par(mfrow = c(2, 2))
boxplot(rnorm(100),
        main = "Boxplot of rnorm(100)")
boxplot(matrix(rnorm(100), ncol = 10),
        main = "Boxplot of matrix(rnorm(100), ncol = 10)")
hist(rnorm(100))
hist(matrix(rnorm(100), ncol = 10))
```

L'approche 'clé sur porte' de _base graphics_ peut être très efficace pour
des figures simples et standards, qui peuvent être produites très rapidement avec une seule ligne de code et une seule fonction telle que `plot`, `hist`, ou
`boxplot`, ... Les valeurs par défaut ne sont cependant pas toujours les plus pertinentes
et le peaufinage des figures peut devenir long et fastidieux, surtout lorsqu'elles deviennent plus complexes (par exemple pour le _faceting_).

### Le package _lattice_

Le package **`lattice`** est similaire à `ggplot2` dans le sens où il utilise des _data frames_ en entrée, renvoie des objets graphiques et prend en charge le _faceting_.
Cependant, `lattice` n'est pas basé sur la _Grammar of Graphics_ et a une interface plus
alambiquée.

A good reference for the `lattice` package is @latticebook.

:::::::::::::::::::::::::::::::::::::::: keypoints

- Visualization in R

::::::::::::::::::::::::::::::::::::::::::::::::::
