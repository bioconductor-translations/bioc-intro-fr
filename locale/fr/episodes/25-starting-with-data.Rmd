---
source: Rmd
title: Starting with data
teaching: 30
exercises: 30
---

```{r, include=FALSE}

```

::::::::::::::::::::::::::::::::::::::: objectives

- Décrire ce qu'est un data frame.
- Charger des données externes à partir d'un fichier .csv dans un data frame.
- Résumer le contenu d'un data frame.
- Décrire ce qu'est un facteur.
- Convertissez entre les chaînes de caractère et les facteurs.
- Réorganiser et renommer les facteurs.
- Formatez les dates.
- Exporter et enregistrez les données.

::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::: questions

- Première analyse de données dans R.

::::::::::::::::::::::::::::::::::::::::::::::::::

> Cet épisode est basé sur la leçon _Analyse des données et
> Visualisation dans R pour les écologistes_ de Data Carpentries.

## Presentation of the gene expression data

We are going to use part of the data published by Blackmore , _The
effect of upper-respiratory infection on transcriptomic changes in the
CNS_. Le but de l'étude était de déterminer l'effet d'une infection des voies respiratoires supérieures sur les modifications de la transcription de l'ARN se produisant dans le cervelet et la moelle épinière après l'infection. Des souris C57BL/6, âgées de huit semaines et appariées selon le genre, ont été inoculées avec une solution saline ou avec la grippe A par voie intranasale et les changements transcriptomiques dans les tissus du cervelet et de la moelle épinière
ont été évalués par RNA-seq aux jours 0 (non infectées), 4 et 8.

L'ensemble de données est stocké sous forme de fichier CSV (_comma-separated values_ ou valeurs séparées par des virgules).  Chaque ligne
contient des informations pour une seule mesure d'expression d'ARN. Les onze premières colonnes représentent :

| Column     | Description                                                                                                                                                                               |
| ---------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| gene       | Le nom du gène qui a été mesuré.                                                                                                                                          |
| sample     | Le nom de l’échantillon dans lequel l’expression du gène a été mesurée.                                                                                                   |
| expression | La valeur de l'expression des gènes.                                                                                                                                      |
| organism   | L'organisme/l'espèce - ici toutes les données proviennent de souris.                                                                                                      |
| age        | L'âge de la souris (ici toutes les souris ont 8 semaines)                                                                                                              |
| sex        | Le sexe de la souris.                                                                                                                                                     |
| infection  | The infection state of the mouse, i.e. infected with Influenza A or not infected.                                                         |
| strain     | The Influenza A strain.                                                                                                                                                   |
| time       | The duration of the infection (in days).                                                                                                               |
| tissue     | Le tissu utilisé pour l'expérience d'expression génique, c'est-à-dire le cervelet (cerebellum) ou la moelle épinière (spinal cord). |
| mouse      | The mouse unique identifier.                                                                                                                                              |

Nous allons utiliser la fonction R `download.file()` pour télécharger le fichier CSV contenant les données d'expression génique. Nous utiliserons ensuite `read.csv()` pour charger en mémoire le contenu du fichier CSV en tant qu'objet de classe `data.frame`.  Inside the `download.file` command, the
first entry is a character string with the source URL. Cette URL télécharge un fichier CSV à partir d'un dépôt GitHub (GitHub repository). Le second argument : `destfile = "data/rnaseq.csv"` (texte après la virgule) correspond à la destination du fichier sur votre machine locale. You'll need to have a folder on your machine called
`"data"` where you'll download the file. Pour récapituler, cette commande télécharge le fichier distant, le nomme `"rnaseq.csv"` et l'ajoute à un dossier
préexistant nommé `"data"`.

```{r, eval=TRUE}
download.file(url = "https://github.com/carpentries-incubator/bioc-intro/raw/main/episodes/data/rnaseq.csv",
              destfile = "data/rnaseq.csv")
```

Vous êtes maintenant prêt à charger les données dans `R`:

```{r, eval=TRUE, purl=TRUE}
rna <- read.csv("data/rnaseq.csv")
```

Cette instruction ne produit aucune sortie dans la console car, comme vous vous en souvenez peut-être, les commandes d'assignation n'affichent rien. Si nous voulons vérifier que nos données ont bien été chargées, nous pouvons voir le contenu du data frame (tableau de données) en en tapant son nom :

```{r, eval=FALSE}
rna
```

Wow... cela fait beaucoup de lignes de sorties. Cela signifie que les données ont été chargées correctement dans l'environnement de travail. Vérifions le haut (les 6 premières lignes) de ce data frame
en utilisant la fonction `head()` :

```{r, purl=TRUE}
head(rna)
## Try also
## View(rna)
```

**Note**

`read.csv()` suppose que les champs soient délimités par des virgules. Cependant, dans plusieurs pays et notamment en France, la virgule est utilisée comme séparateur décimal et le point-virgule (;) est utilisé comme délimiteur de champ. Si vous souhaitez lire ce type de fichiers dans R, vous pouvez utiliser la fonction `read.csv2()`. Il se comporte exactement comme `read.csv()` mais utilise des paramètres différents pour la décimale et les séparateurs de champ. Si vous travaillez avec un autre format de données
, ces paramètres peuvent tous deux être spécifiés explicitement par l'utilisateur. Consultez l'aide de la fonction `read.csv()` en tapant `?read.csv` pour en savoir plus. Il existe également la fonction
`read.delim()` pour lire des fichiers de données séparées par des tabulations. It is important to
note that all of these functions are actually wrapper functions for
the main `read.table()` function with different arguments.  Par exemple, les données ci-dessus auraient également pu être chargées en utilisant `read.table()` avec l'argument de séparation (`sep`) égal à `","` selon le code suivant :

```{r, eval=TRUE, purl=TRUE}
rna <- read.table(file = "data/rnaseq.csv",
                  sep = ",",
                  header = TRUE)
```

L'argument `header` (en-tête) doit être défini comme étant `TRUE` pour pouvoir lire les en-têtes du fichier CSV, puisque par défaut dans `read.table()`, l'argument `header` défini comme étant `FALSE`.

## Qu'est-ce qu'un data frame ?

Data frames are the _de facto_ data structure for most tabular data,
and what we use for statistics and plotting.

Un data frame peut être créé à la main, mais le plus souvent celui-ci est
générés par les fonctions `read.csv()` ou `read.table()`, c'est-à-dire lors de l'importation de feuilles de calcul depuis votre disque dur (ou le web).

Le data frame représente les données sous la forme d'un tableau
où les colonnes sont des vecteurs qui ont tous la même longueur. Étant donné que les colonnes
sont des vecteurs (de classe `vector`), chaque colonne doit contenir un seul type de données
(par exemple, des caractères, des entiers, des facteurs). Par exemple, voici une figure
représentant un data frame comprenant trois vecteurs : un numérique, un  caractère et un logique.

![](./fig/data-frame.svg)

Nous pouvons le voir lors de l'inspection de la <b>str</b>ucture d'un data frame avec la fonction `str()` :

```{r}
str(rna)
```

## Inspecting `data.frame` Objects

Nous avons déjà vu comment les fonctions `head()` et `str()` peuvent être utiles pour vérifier le contenu et la structure d'un data frame. Voici une
liste non exhaustive de fonctions pour avoir une idée du
contenu ou de la structure des données. Let's try them out!

**Dimension** :

- `dim(rna)` - renvoie un vecteur avec le nombre de lignes comme premier élément
  et le nombre de colonnes comme deuxième élément (les
  **dim**ensions de l'objet).
- `nrow(rna)` - returns the number of rows.
- `ncol(rna)` - returns the number of columns.

**Contenu** :

- `head(rna)` - shows the first 6 rows.
- `tail(rna)` - shows the last 6 rows.

**Noms** :

- `names(rna)` - returns the column names (synonym of `colnames()` for
  `data.frame` objects).
- `rownames(rna)` - returns the row names.

**Résumé** :

- `str(rna)` - structure of the object and information about the
  class, length and content of each column.
- `summary(rna)` - summary statistics for each column.

Remarque : la plupart de ces fonctions sont "génériques", c'est-à-dire qu'elles peuvent être utilisées sur d'autres types d'objets
en plus des objets `data.frame`.

:::::::::::::::::::::::::::::::::::::::  challenge

## Défi:

Based on the output of `str(rna)`, can you answer the following
questions?

- Quelle est la classe de l’objet `rna` ?
- How many rows and how many columns are in this object?

:::::::::::::::  solution

## Solution

- classe : data frame
- how many rows: `r nrow(rna)`, how many columns: `r ncol(rna)`

:::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::::

## Indexation et création de sous-ensembles de data frames

Notre data frame « rna » comporte des lignes et des colonnes (il a 2 dimensions) ; si nous
voulons en extraire des données spécifiques, nous devons spécifier les
"coordonnées" que nous voulons. Les numéros de ligne viennent en premier, suivis des numéros de colonne. Cependant, notez qu'il y a différentes manières de spécifier ces coordonnées,
conduisant à des résultats avec des classes différentes.

```{r, eval=FALSE, purl=TRUE}
# first element in the first column of the data frame (as a vector)
rna[1, 1]
# first element in the 6th column (as a vector)
rna[1, 6]
# first column of the data frame (as a vector)
rna[, 1]
# first column of the data frame (as a data.frame)
rna[1]
# first three elements in the 7th column (as a vector)
rna[1:3, 7]
# the 3rd row of the data frame (as a data.frame)
rna[3, ]
# equivalent to head_rna <- head(rna)
head_rna <- rna[1:6, ]
head_rna
```

`:` est une fonction spéciale qui crée des vecteurs numériques d'entiers dans un
ordre croissant ou décroissant. Testez `1:10` et `10:1` par exemple. Voir section @ref(sec:genvec) pour plus de détails.

Vous pouvez également exclure certains indices d'un data frame à l'aide du signe "`-`" :

```{r, eval=FALSE, purl=TRUE}
rna[, -1]          ## The whole data frame, except the first column
rna[-c(7:66465), ] ## Equivalent to head(rna)
```

L'on peut créer des sous-ensembles à partir des data frames en utilisant des indices (comme vu précédemment),
mais aussi en appelant directement les noms de colonnes à extraire :

```{r, eval=FALSE, purl=TRUE}
rna["gene"]       # Result is a data.frame
rna[, "gene"]     # Result is a vector
rna[["gene"]]     # Result is a vector
rna$gene          # Result is a vector
```

Dans RStudio, vous pouvez utiliser la fonctionnalité de saisie automatique pour obtenir les noms complets et
corrects des colonnes.

:::::::::::::::::::::::::::::::::::::::  challenge

## Challenge

1. Créez un `data.frame` (`rna_200`) contenant uniquement les données de la ligne 200 du jeu de données `rna`.

2. Notez comment `nrow()` vous a donné le nombre de lignes dans un `data.frame` ?

- Utilisez ce chiffre pour extraire uniquement la dernière ligne du data frame initial
  `rna`.

- Comparez ceci avec la dernière ligne du data frame en utilisant `tail()` pour s'assurer d'obtenir des résultats identiques.

- Extrayez à présent cette dernière ligne en utilisant `nrow()` au lieu du numéro de ligne.

- Créez un nouveau data frame (`rna_last`) à partir de cette dernière ligne.

3. Utilisez `nrow()` pour extraire la ligne qui se trouve au milieu du data frame
  `rna`. Store the content of this row in an object
  named `rna_middle`.

4. Combinez `nrow()` avec la notation `-` ci-dessus pour reproduire le comportement
  de `head(rna)`, en conservant uniquement les lignes 1 à 6 du data frame `rna`.

:::::::::::::::  solution

## Solution

```{r, purl=TRUE}
## 1.
rna_200 <- rna[200, ]
## 2.
## Saving `n_rows` to improve readability and reduce duplication
n_rows <- nrow(rna)
rna_last <- rna[n_rows, ]
## 3.
rna_middle <- rna[n_rows / 2, ]
## 4.
rna_head <- rna[-(7:n_rows), ]
```

:::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::::

## Factors

Factors represent **categorical data**. Ils sont stockés sous forme d'entiers (integer) avec des étiquettes associées et ils peuvent être ordonnés ou non. Alors que les facteurs
ressemblent (et se comportent souvent) comme des vecteurs de caractères, ils sont
en réalité traités comme des vecteurs entiers par R. Vous devez donc être très
prudent lorsque vous les traitez comme des chaînes.

Once created, factors can only contain a pre-defined set of values,
known as _levels_. Par défaut, R trie toujours les niveaux par ordre alphabétique. For instance, if you have a factor with 2 levels:

```{r, purl=TRUE}
sex <- factor(c("male", "female", "female", "male", "female"))
```

R va assigner `1` au niveau `"female"` et `2` au niveau
`"male"` (puisque `f` vient avant `m`, même si le premier élément
de ce vecteur est `"male"`). Vous pouvez le vérifier en utilisant la fonction
`levels()` et vous pouvez trouver le nombre de niveaux en utilisant `nlevels()` :

```{r, purl=TRUE}
levels(sex)
nlevels(sex)
```

Parfois, l'ordre des facteurs n'a pas d'importance, d'autres fois vous
pourriez vouloir spécifier l'ordre car il est pertinent (par exemple, "faible",
"moyen", "élevé"), il améliore votre visualisation, ou il est requis
par un type particulier d'analyse. Ici, une façon de réorganiser nos niveaux
dans le vecteur `sex` serait :

```{r, purl=TRUE}
sex ## current order
sex <- factor(sex, levels = c("male", "female"))
sex ## after re-ordering
```

Ces facteurs sont représentés par des entiers (ex: 1, 2, 3) dans la mémoire de R
mais ils sont plus informatifs que les entiers car les facteurs se décrivent d'eux-mêmes
: `"female"`, `"male" ` est plus descriptif que `1`,
`2`. Lequel est « male » ?  You wouldn't be able to tell just from the
integer data. Factors, on the other hand, have this information built-in.
It is particularly helpful when there are many levels (like the
gene biotype in our example dataset).

Lorsque vos données sont stockées sous forme de facteur, vous pouvez utiliser la fonction `plot()` pour obtenir un aperçu rapide du nombre d'observations
représenté par chaque niveau de facteur. Let's look at the number of males
and females in our data.

```{r firstfactorplot, fig.cap="Bar plot of the number of females and males.", purl=TRUE}
plot(sex)
```

### Conversion en chaîne de caractères

Un facteur peut être converti en vecteur caractère, vous pouvez utiliser la fonction
`as.character(x)`.

```{r, purl=TRUE}
as.character(sex)
```

<!-- ### Numeric factors -->

<!-- Converting factors where the levels appear as numbers (such as -->

<!-- concentration levels, or years) to a numeric vector is a little -->

<!-- trickier. The `as.numeric()` function returns the index values of the -->

<!-- factor, not its levels, so it will result in an entirely new (and -->

<!-- unwanted in this case) set of numbers.  One method to avoid this is to -->

<!-- convert factors to characters, and then to numbers.  Another method is -->

<!-- to use the `levels()` function. Compare: -->

<!-- ```{r} -->

<!-- year_fct <- factor(c(1990, 1983, 1977, 1998, 1990)) -->

<!-- as.numeric(year_fct)  ## Wrong! And there is no warning... -->

<!-- as.numeric(as.character(year_fct)) ## Works... -->

<!-- as.numeric(levels(year_fct))[year_fct] ## The recommended way. -->

<!-- ```

<!-- Notice that in the `levels()` approach, three important steps occur: -->

<!-- * We obtain all the factor levels using `levels(year_fct)` -->

<!-- * We convert these levels to numeric values using `as.numeric(levels(year_fct))` -->

<!-- * We then access these numeric values using the underlying integers of the -->

<!--   vector `year_fct` inside the square brackets -->

### Renommer les facteurs

Si l'on veut renommer ces facteurs, il suffit de changer ses niveaux avec la fonction `levels()`
:

```{r, purl=TRUE}
levels(sex)
levels(sex) <- c("M", "F")
sex
plot(sex)
```

::::::::::::::::::::::::::::::::::::::  challenge

## Défi:

- Renommez `F` et `M` respectivement en `Female` et `Male`.

:::::::::::::::  solution

## Solution

```{r, eval=TRUE, purl=TRUE}
levels(sex)
levels(sex) <- c("Male", "Female")
```

:::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::  challenge

## Défi:

Nous avons vu comment les data frame sont créés avec `read.csv()`, mais
ils peuvent également être créés à la main avec la fonction `data.frame()`.
Il y a quelques erreurs dans ce `data.frame` construit manuellement. Pouvez-vous
les repérer et les corriger ?  Don't hesitate to experiment!

```{r, eval=FALSE}
animal_data <- data.frame(
       animal = c(dog, cat, sea cucumber, sea urchin),
       feel = c("furry", "squishy", "spiny"),
       weight = c(45, 8 1.1, 0.8))
```

:::::::::::::::  solution

## Solution

- Les guillemets sont manquants autour des noms des animaux.
- Il manque une entrée dans la colonne `feel` (probablement pour l'un des animaux à fourrure).
- Il manque une virgule dans la colonne `weight`.

:::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::  challenge

## Défi:

Can you predict the class for each of the columns in the following
example?

Check your guesses using `str(country_climate)`:

- Are they what you expected?  Pourquoi ? Why not?

- Réessayez en ajoutant `stringsAsFactors = TRUE` après la dernière variable
  lors de la création du data frame. Que se passe-t-il à présent ?
  `stringsAsFactors` can also be set when reading text-based
  spreadsheets into R using `read.csv()`.

```{r, eval=FALSE, purl=TRUE}
country_climate <- data.frame(
       country = c("Canada", "Panama", "South Africa", "Australia"),
       climate = c("cold", "hot", "temperate", "hot/temperate"),
       temperature = c(10, 30, 18, "15"),
       northern_hemisphere = c(TRUE, TRUE, FALSE, "FALSE"),
       has_kangaroo = c(FALSE, FALSE, FALSE, 1)
       )
```

:::::::::::::::  solution

## Solution

```{r, eval=TRUE, purl=TRUE}
country_climate <- data.frame(
       country = c("Canada", "Panama", "South Africa", "Australia"),
       climate = c("cold", "hot", "temperate", "hot/temperate"),
       temperature = c(10, 30, 18, "15"),
       northern_hemisphere = c(TRUE, TRUE, FALSE, "FALSE"),
       has_kangaroo = c(FALSE, FALSE, FALSE, 1)
       )
str(country_climate)
```

:::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::::

The automatic conversion of data type is sometimes a blessing, sometimes an
annoyance. Sachez que cela existe, apprenez les règles et vérifiez que les données
que vous importez dans R sont du bon type dans votre data frame. If not, use it
to your advantage to detect mistakes that might have been introduced during data
entry (a letter in a column that should only contain numbers for instance).

Learn more in this RStudio
tutorial

## Matrices

Avant de continuer, maintenant que nous avons découvert les data frames,
récapitulons l'installation de packages et découvrons un nouveau type de données, à savoir la classe `matrix`. Comme un objet de classe `data.frame`, une matrice a deux dimensions, des lignes et
colonnes. La différence majeure est que toutes les cellules d'une matrice doivent
être du même type : « numérique », « caractère », « logique », ... À cet égard, les matrices sont plus proches d'un vecteur que d'un data frame.

Le constructeur par défaut d'une matrice est « matrix ». Le remplissage de la matrice nécessite un vecteur de
valeurs et de fixer le nombre de lignes et/ou
colonnes\[^`ncol`]. The values are sorted along the columns, as illustrated
below.

```{r mat1, purl=TRUE}
m <- matrix(1:9, ncol = 3, nrow = 3)
m
```

[^ncol]: Définir uniquement le nombre de lignes ou de colonnes est suffisant, l'autre dimension pouvant être déduite de la valeur fournie. Essayez de voir ce qu'il se passe si le produit entre le nombre de lignes/colonnes et le nombre de valeurs ne correspondent pas.

:::::::::::::::::::::::::::::::::::::::  challenge

## Défi:

À l'aide de la fonction `installed.packages()`, créez une matrice caractère
contenant les informations sur tous les packages actuellement installés sur
votre ordinateur. Explorez-la.

:::::::::::::::  solution

## Solution

```{r pkg_sln, eval=FALSE, purl=TRUE}
## create the matrix
ip <- installed.packages()
head(ip)
## try also View(ip)
## number of package
nrow(ip)
## names of all installed packages
rownames(ip)
## type of information we have about each package
colnames(ip)
```

:::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::::

Il est souvent utile de créer de grandes matrices de données aléatoires comme données de test. The exercise below asks you to create such a matrix with random
data drawn from a normal distribution of mean 0 and standard deviation
1, which can be done with the `rnorm()` function.

:::::::::::::::::::::::::::::::::::::::  challenge

## Défi:

Construire une matrice de dimension 1000 (nombre de lignes) par 3 (nombre de colonnes) de données normalement distribuées
(moyenne 0, écart type 1).

:::::::::::::::  solution

## Solution

```{r rnormmat_sln, purl=TRUE}
set.seed(123)
m <- matrix(rnorm(3000), ncol = 3)
dim(m)
head(m)
```

:::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::::

## Formatting Dates

L'un des problèmes les plus courants rencontrés par les nouveaux (et les plus expérimentés !)  utilisateurs de R concerne
la conversion des informations de date et d'heure en une variable
appropriée et utilisable lors des analyses.

### Note on dates in spreadsheet programs

Dates in spreadsheets are generally stored in a single column. Bien que
cela semble la manière la plus naturelle d'enregistrer des dates, ce ne fait en réalité pas partie des bonnes pratiques. Un tableur affichera les dates d'une manière
apparemment correcte (pour un observateur humain), mais la façon dont il
gère et stocke réellement les dates peut être problématique. It is often much
safer to store dates with YEAR, MONTH and DAY in separate columns or
as YEAR and DAY-OF-YEAR in separate columns.

Des tableurs tels que LibreOffice, Microsoft Excel, OpenOffice,
Gnumeric, ... ont des manières différentes (et souvent incompatibles) d'encoder les dates
(même pour le même programme entre les versions et les systèmes d'exploitation). Additionally, Excel can turn things that aren't dates into
dates
(@Zeeberg:2004), for example names or identifiers like MAR1, DEC1,
OCT4. Donc, si vous évitez de façon générale le format date, il est plus facile d'identifier ces problèmes.

The Dates as
data
section of the Data Carpentry lesson provides additional insights
about pitfalls of dates with spreadsheets.

We are going to use the `ymd()` function from the package
**`lubridate`** (which belongs to the **`tidyverse`**; learn more
[here](https://www.tidyverse.org/)). . **`lubridate`** est automatiquement installé lors de l'installation de **`tidyverse`**. Lorsque vous chargez le
**`tidyverse`** (commande `library(tidyverse)`), les packages de base (les packages
utilisés dans la plupart des analyses de données) sont chargés. **`lubridate`**
n'appartient cependant pas aux fonctionnalités de base de tidyverse, vous devez donc le charger
explicitement avec `library(lubridate)`.

Start by loading the required package:

```{r loadlibridate, message=FALSE, purl=TRUE}
library("lubridate")
```

`ymd()` takes a vector representing year, month, and day, and converts
it to a `Date` vector. `Date` is a class of data recognized by R as
being a date and can be manipulated as such. L'argument requis par la fonction
est flexible, mais, à titre de bonnes pratiques, il s'agit d'un vecteur de caractère
au format "AAAA-MM-JJ".

Let's create a date object and inspect the structure:

```{r, purl=TRUE}
my_date <- ymd("2015-01-01")
str(my_date)
```

Now let's paste the year, month, and day separately - we get the same result:

```{r, purl=TRUE}
# sep indicates the character to use to separate each component
my_date <- ymd(paste("2015", "1", "1", sep = "-"))
str(my_date)
```

Let's now familiarise ourselves with a typical date manipulation
pipeline. Le data frame ci-dessous a stocké des dates dans différentes colonnes « year »,
« month » et « jour ».

```{r, purl=TRUE}
x <- data.frame(year = c(1996, 1992, 1987, 1986, 2000, 1990, 2002, 1994, 1997, 1985),
                month = c(2,  3,  3, 10,  1,  8,  3,  4,  5,  5),
                day = c(24,  8,  1,  5,  8, 17, 13, 10, 11, 24),
                value = c(4,  5,  1,  9,  3,  8, 10,  2,  6,  7))
x
```

Nous appliquons maintenant cette fonction à l'ensemble du jeu de données « x ». We first create a
character vector from the `year`, `month`, and `day` columns of `x`
using `paste()`:

```{r, purl=TRUE}
paste(x$year, x$month, x$day, sep = "-")
```

This character vector can be used as the argument for `ymd()`:

```{r, purl=TRUE}
ymd(paste(x$year, x$month, x$day, sep = "-"))
```

The resulting `Date` vector can be added to `x` as a new column called `date`:

```{r, purl=TRUE}
x$date <- ymd(paste(x$year, x$month, x$day, sep = "-"))
str(x) # notice the new column, with 'date' as the class
```

Let's make sure everything worked correctly. Une façon d'inspecter la nouvelle colonne
est d'utiliser la fonction `summary()` :

```{r, purl=TRUE}
summary(x$date)
```

Notez que `ymd()` s'attend à avoir successivement l'année, le mois et le jour. Si vous avez par exemple le jour, le mois et l'année, vous aurez besoin de la fonction
`dmy()`.

```{r, purl=TRUE}
dmy(paste(x$day, x$month, x$year, sep = "-"))
```

`lubdridate` a de nombreuses fonctions pour gérer toutes les variantes de date.

## Summary of R objects

So far, we have seen several types of R object varying in the number
of dimensions and whether they could store a single or multiple data
types:

- **`vector`** : une dimension (ils ont une longueur), un seul type de données.
- **`matrix`** : deux dimensions, un seul type de données.
- **`data.frame`**: two dimensions, one type per column.

## Lists

Un type de données que nous n'avons pas encore vu, mais qu'il est utile de connaître, et
découle du résumé que nous venons de voir sont des listes (classe `list`) :

- **`list`**: one dimension, every item can be of a different data
  type.

Ci-dessous, créons une liste contenant un vecteur de nombres, de caractères,
une matrice, un data frame et une autre liste :

```{r list0, purl=TRUE}
l <- list(1:10, ## numeric
          letters, ## character
          installed.packages(), ## a matrix
          cars, ## a data.frame
          list(1, 2, 3)) ## a list
length(l)
str(l)
```

L'indiçage (i.e. la réalisation d'un sous-ensemble) de liste est effectué en utilisant `[]` pour créer une nouvelle sous-liste ou `[[]]`
pour extraire un seul élément de cette liste (en utilisant des indices ou des noms si
la liste possède un attribut de nom).

```{r, purl=TRUE}
l[[1]] ## first element
l[1:2] ## a list of length 2
l[1]   ## a list of length 1
```

## Exporting and saving tabular data {#sec:exportandsave}

We have seen how to read a text-based spreadsheet into R using the
`read.table` family of functions. Pour exporter un `data.frame` vers une feuille de calcul texte
, nous pouvons utiliser l'ensemble de fonctions `write.table` (`write.csv`, `write.delim`, ...). Ils ont tous pour arguments la variable à
exporter et le fichier vers lequel exporter. Par exemple, pour exporter les données
`rna` vers le fichier `my_rna.csv` dans le répertoire `data_output`, nous exécuterions :

```{r writecsv, eval=FALSE, purl=TRUE}
write.csv(rna, file = "data_output/my_rna.csv")
```

Ce nouveau fichier csv peut maintenant être partagé avec d'autres collaborateurs qui ne sont pas familiers avec R. Notez que même s'il y a des virgules dans certains des champs dans le `data.frame` (voir par exemple la colonne "product"), R entourera par défaut chaque champ de texte avec des guillemets. Nous serons donc en mesure de
le lire à nouveau dans R correctement, malgré l'utilisation de virgules comme séparateurs de colonnes.

:::::::::::::::::::::::::::::::::::::::: keypoints

- Tabular data in R

::::::::::::::::::::::::::::::::::::::::::::::::::
