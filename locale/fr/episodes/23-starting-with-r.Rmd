---
source: Rmd
title: Introduction to R
teaching: 60
exercises: 60
---

```{r, include=FALSE}

```

::::::::::::::::::::::::::::::::::::::: objectives

- Définir les termes suivants relatifs à R : objet, affectation, appel, fonction, arguments, options.
- Attribuer des valeurs aux objets dans R.
- Learn how to _name_ objects
- Utiliser des commentaires pour informer le script.
- Solve simple arithmetic operations in R.
- Appeler des fonctions et utiliser des arguments pour modifier leurs options par défaut.
- Inspecter le contenu des vecteurs et manipulez leur contenu.
- Extraire un sous-ensemble ou des valeurs à partir de vecteurs.
- Analyser des vecteurs contenant des données manquantes.

::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::: questions

- First commands in R

::::::::::::::::::::::::::::::::::::::::::::::::::

> Cet épisode est basé sur la leçon _Analyse des données et
> Visualisation dans R pour les écologistes_ de Data Carpentries.

## Creating objects in R

En R, vous pouvez obtenir des résultats simplement en tapant des opérations mathématiques directement dans la console :

```{r, purl=TRUE}
3 + 5
12 / 7
```

However, to do useful and interesting things, we need to assign _values_ to
_objects_. Pour créer un objet, nous devons lui donner un nom suivi de l'opérateur d'assignation \`←

```{r, purl=TRUE}
weight_kg <- 55
```

`<-` est l'opérateur d'assignation (affectation). Il attribue des valeurs à droite aux objets à gauche. Ainsi, après avoir exécuté `x <- 3`, la valeur de `x` est `3`. The arrow can be read as 3 **goes into** `x`.  Pour des raisons historiques, vous pouvez également utiliser `=` pour les assignations, mais pas dans tous les contextes. En raison de [légères différences](https://blog.revolutionanalytics.com/2008/12/use-equals-or-arrow-for-assignment.html) dans la syntaxe, une bonne pratique est de toujours utiliser `<-` pour les assignations.

In RStudio, typing <kbd>Alt</kbd> + <kbd>\-</kbd> (push <kbd>Alt</kbd>
at the same time as the <kbd>\-</kbd> key) will write `<-` in a single
keystroke in a PC, while typing <kbd>Option</kbd> + <kbd>\-</kbd> (push <kbd>Option</kbd> at the same time as the <kbd>\-</kbd> key) does the
same in a Mac.

### Naming variables

Les objets peuvent avoir n'importe quel nom tel que « x », « current_temperature » ou « subject_id ». Il est souhaitable que les noms de vos objets soient explicites et pas trop
longs. Ils ne peuvent pas commencer par un nombre (`2x` n'est pas un nom valide, mais `x2` l'est). R is case sensitive (e.g., `weight_kg` is different from
`Weight_kg`). Certains noms ne peuvent pas être utilisés car ils
sont les noms de fonctions fondamentales dans R (par exemple, `if`, `else`,
`for`, voir
[ici](https://stat.ethz.ch/R-manual/R-devel/library/base/html/Reserved.html)
pour une liste complète des noms réservés). En général, même si c'est autorisé, il est préférable de
de ne pas utiliser d'autres noms de fonctions (par exemple, `c`, `T`, `mean`, `data`, `df`, ` weight`). If in doubt, check the help to see if the name is already
in use. Il est également préférable d'éviter les points (`.`) dans un nom d'objet comme dans `my.dataset` (utilisez plutôt `my_dataset` par exemple). Vous remarquerez cependant qu'il existe de nombreuses fonctions dans R avec des points dans leurs noms. Ces noms de fonction sont conservés pour des raisons historiques, mais comme les points ont une signification particulière en R (pour les méthodes) et autres langages de programmation, il est préférable de les éviter. Il est également recommandé d'utiliser des noms pour les noms d'objets et des verbes pour les noms de fonctions. Il est important d'être cohérent dans le style de votre code (où vous placez les espaces, comment vous nommez les objets, etc.). L'utilisation d'un style de codage cohérent rend votre code plus clair à lire pour vos collaborateurs, mais aussi pour vous-même dans le futur (vous vous remercierez plus tard). In R, some popular style guides
are [Google's](https://google.github.io/styleguide/Rguide.xml), the
[tidyverse's](https://style.tidyverse.org/) style and the Bioconductor
style
guide. Le style Tidyverse est très complet mais peut sembler un peu lourd au début. Vous pouvez installer le package
[**`lintr`**](https://github.com/jimhester/lintr) qui
vérifiera et corrigera automatiquement les problèmes ou incohérences dans le style de votre code.

> **Objets et variables** : ce que l'on appelle des « objets » en « R » sont
> connus sous le nom de « variables » dans de nombreux autres langages de programmation. Depending
> on the context, `object` and `variable` can have drastically
> different meanings. Cependant, dans cette leçon, les deux mots sont utilisés de manière synonyme. Pour plus d'informations
> [voir ce lien.](https://cran.r-project.org/doc/manuals/r-release/R-lang.html#Objects)

Lors de l'attribution d'une valeur à un objet, R n'imprime rien dans la console. Vous pouvez forcer R à imprimer la valeur d'un objet en utilisant des parenthèses ou en tapant le nom de l'objet :

```{r, purl=TRUE}
weight_kg <- 55    # doesn't print anything
(weight_kg <- 55)  # but putting parenthesis around the call prints the value of `weight_kg`
weight_kg          # and so does typing the name of the object
```

Maintenant que R a `weight_kg` en mémoire, nous pouvons faire des opérations arithmétiques sur cet objet. Par exemple, nous pouvons vouloir convertir ce poids en livres (le poids en livres est 2,2 fois le poids en kg) :

```{r, purl=TRUE}
2.2 * weight_kg
```

On peut également changer la valeur d'un objet en lui attribuant une nouvelle valeur :

```{r, purl=TRUE}
weight_kg <- 57.5
2.2 * weight_kg
```

L'attribution d'une valeur à un objet ne modifie pas les valeurs d'autres objets. Par exemple, stockons le poids en livres dans un nouvel objet `weight_lb` :

```{r, purl=TRUE}
weight_lb <- 2.2 * weight_kg
```

puis remplacons `weight_kg` par 100.

```{r}
weight_kg <- 100
```

:::::::::::::::::::::::::::::::::::::::  challenge

## Défi:

Selon vous, quel est maintenant le contenu de l'objet `weight_lb` ?
126\.5 ou 220?

::::::::::::::::::::::::::::::::::::::::::::::::::

## Commentaires

En R, le caractère de commentaire est `#`. Tout ce qui se trouve à droite d'un `#` dans un script sera ignoré par R. Les commentaires sont utiles pour laisser des notes et explications dans vos scripts.

RStudio permet de facilement commenter ou "décommenter" un paragraphe : après avoir sélectionné les lignes que vous souhaitez commenter (ou décommenter), appuyez simultanément sur les touches <kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>C</kbd>. Si vous ne souhaitez commenter qu'une seule ligne, vous pouvez placer le curseur à n'importe quel emplacement de cette ligne (il n'est pas nécessaire de sélectionner la ligne entière), puis appuyez sur <kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>C</kbd>.

:::::::::::::::::::::::::::::::::::::::  challenge

## Challenge

Quelles sont les valeurs des objets après chaque instruction ci-dessous ?

```{r, purl=TRUE}
mass <- 47.5            # mass?
age  <- 122             # age?
mass <- mass * 2.0      # mass?
age  <- age - 20        # age?
mass_index <- mass/age  # mass_index?
```

::::::::::::::::::::::::::::::::::::::::::::::::::

## Les fonctions et leurs arguments

Les fonctions sont des "scripts prédéfinis" qui automatisent des ensembles de commandes plus complexes, y compris les affectations d'opérations. Many functions are predefined, or can be
made available by importing R _packages_ (more on that later). A function
usually gets one or more inputs called _arguments_. Functions often (but not
always) return a _value_. A typical example would be the function `sqrt()`. L'entrée
(l'argument) doit être un nombre et la valeur de retour (la "sortie") est la racine carrée de ce nombre. Executing a function ('running it')
is called _calling_ the function. An example of a function call is:

```{r, eval=FALSE, purl=FALSE}
b <- sqrt(a)
```

Ici, la valeur de `a` est donnée à la fonction `sqrt()`, la fonction `sqrt()`
en calcule la racine carrée, et renvoie cette valeur qui est ensuite attribuée à
l'objet `b`. Cette fonction est simple car elle ne prend qu’un seul argument.

La valeur de retour d'une fonction (sa sortie) n'est pas nécessairement numérique (comme celle de `sqrt()`), et elle n'est pas forcément un élément unique : une sortie peut être un ensemble de choses, ou
même un jeu de données. Nous en verrons un exemple lorsque nous lirons des fichiers de données dans R.

Les arguments peuvent aussi être divers, pas uniquement des nombres ou noms de fichiers, mais aussi d'autres objets (listes, jeux de données, etc.). Exactly what each argument means differs per function, and must be
looked up in the documentation (see below). Some functions take arguments which
may either be specified by the user, or, if left out, take on a _default_ value:
these are called _options_. Les options sont généralement utilisées pour modifier le fonctionnement de la fonction, par exemple si elle doit ignorer les « mauvaises valeurs » ou quel symbole utiliser dans un graphique.  Si vous souhaitez un comportement spécifique pour une fonction, vous pouvez spécifier une valeur de votre choix qui sera utilisée à la place de la valeur par défaut.

Essayons maintenant une fonction qui peut prendre plusieurs arguments : `round()`.

```{r, results="show", purl=TRUE}
round(3.14159)
```

Here, we've called `round()` with just one argument, `3.14159`, and it has
returned the value `3`.  En effet, le comportement par défaut de la fonction `round()` est d'arrondir au nombre entier le plus proche. Si nous souhaitons conserver quelques chiffres décimaux, nous pouvons voir comment procéder en obtenant des informations sur la fonction `round`.  `args(round)` ou `?round` nous permettront d'obternir des informations sur les arguments (optionnels) de la fonction `round`.

```{r, results="show", purl=TRUE}
args(round)
```

```{r, eval=FALSE, purl=TRUE}
?round
```

Nous voyons que si nous souhaitons deux chiffres décimaux, nous pouvons
taper `digits=2`.

```{r, results="show", purl=TRUE}
round(3.14159, digits = 2)
```

If you provide the arguments in the exact same order as they are defined you
don't have to name them:

```{r, results="show", purl=TRUE}
round(3.14159, 2)
```

And if you do name the arguments, you can switch their order:

```{r, results="show", purl=TRUE}
round(digits = 2, x = 3.14159)
```

Il est recommandé de placer les arguments non facultatifs (comme le nombre que vous arrondissez) en premier dans votre appel de fonction et de spécifier les noms de tous les arguments facultatifs.  Si vous ne le faites pas, quelqu'un qui lit votre code devra peut-être rechercher la définition d'une fonction avec des arguments inconnus pour comprendre ce que vous faites. En spécifiant le nom des arguments, vous protégez également votre code
contre d'éventuelles modifications futures dans l'interface de la fonction, qui peuvent potentiellement ajouter de nouveaux arguments entre ceux existants.

## Vectors and data types

Le vecteur est le type de données le plus courant, basique et central de R. Un vecteur est composé d'une série de valeurs, telles que des
nombres ou caractères. We can assign a series of values to a vector using
the `c()` function. For example we can create a vector of animal weights and assign
it to a new object `weight_g`:

```{r, purl=TRUE}
weight_g <- c(50, 60, 65, 82)
weight_g
```

A vector can also contain characters:

```{r, purl=TRUE}
molecules <- c("dna", "rna", "protein")
molecules
```

Les guillemets autour de `"dna"`, `"rna"`, etc. sont ici essentiels. Sans les guillemets, R supposera qu'il existe des objets appelés `dna`, `rna` et
`protein`. As these objects don't exist in R's memory, there will be
an error message.

Il existe de nombreuses fonctions qui vous permettent d'inspecter le contenu d'un vecteur. `length()` tells you how many elements are in a particular vector:

```{r, purl=TRUE}
length(weight_g)
length(molecules)
```

An important feature of a vector, is that all of the elements are the
same type of data.  La fonction `class()` indique la classe (le type d'élément) d'un objet :

```{r, purl=TRUE}
class(weight_g)
class(molecules)
```

La fonction `str()` fournit un aperçu de la structure d'un objet et de ses éléments. C'est une fonction utile lorsque vous travaillez avec des objets volumineux et complexes :

```{r, purl=TRUE}
str(weight_g)
str(molecules)
```

You can use the `c()` function to add other elements to your vector:

```{r}
weight_g <- c(weight_g, 90) # ajout à la fin du vecteur
weight_g <- c(30, weight_g) # ajout au début du vecteur
weight_g
```

Dans la première ligne, nous prenons le vecteur d'origine `weight_g`, y ajoutons la valeur `90` à la fin et enregistrons le résultat dans `weight_g`. Dans la deuxième ligne, nous ajoutons la valeur « 30 » au début, en enregistrant à nouveau le résultat dans « weight_g ».

Nous pouvons continuer à compléter ainsi un vecteur ou utiliser cette syntaxe pour assembler des données.  Cela peut être utile pour ajouter les résultats que nous collectons ou calculons au fur et à mesure de notre analyse.

Un **vecteur atomique** est le **type de données** R le plus simple; il s'agit d'un vecteur linéaire composé d'éléments du même type. Plus tôt, nous avons vu 2 des 6 principaux types de vecteurs **atomiques** que R utilise : `"character"` (caractères) et `"numeric"` (chiffres, décimaux ou entiers) (ou `"double"` (réels)). These are the basic building blocks that all R objects
are built from. The other 4 **atomic vector** types are:

- `"logical"` pour `TRUE` et `FALSE` (le type de données booléen)
- `"integer"` for integer numbers (e.g., `2L`, the `L` indicates to R
  that it's an integer)
- `"complex"` pour représenter des nombres complexes avec des parties réelles et imaginaires (par exemple, `1 + 4i`); et c'est tout ce que dirons à leur sujet
- `"raw"` pour les "flux de bits" (bitstreams) dont nous ne parlerons pas davantage

You can check the type of your vector using the `typeof()` function
and inputting your vector as the argument.

Vectors are one of the many **data structures** that R uses. Les autres structures importantes sont les listes (`list`), les matrices (`matrix`), les tables de données (`data.frame`), les facteurs (`factor`) et les tableaux (`array` ).

:::::::::::::::::::::::::::::::::::::::  challenge

## Défi:

We've seen that atomic vectors can be of type character, numeric (or
double), integer, and logical. Que se passe-t-il si nous essayons de mélanger
ces types dans un seul vecteur ?

:::::::::::::::  solution

## Solution

R implicitly converts them to all be the same type

:::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::  challenge

## Défi:

What will happen in each of these examples? (indice : utilisez la fonction `class()` pour vérifier le type de données des objets) :

```{r, eval=TRUE}
num_char <- c(1, 2, 3, "a")
num_logical <- c(1, 2, 3, TRUE, FALSE)
char_logical <- c("a", "b", "c", TRUE)
tricky <- c(1, 2, 3, "4")
```

:::::::::::::::  solution

## Solution

```{r, purl=TRUE}
class(num_char)
num_char
class(num_logical)
num_logical
class(char_logical)
char_logical
class(tricky)
tricky
```

:::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::  challenge

## Défi:

Why do you think it happens?

:::::::::::::::  solution

## Solution

Les éléments des vecteurs ne peuvent appartenir qu’à un seul type de données. R tries to convert (coerce)
the content of this vector to find a _common denominator_ that
doesn't lose any information.

:::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::  challenge

## Défi:

How many values in `combined_logical` are `"TRUE"` (as a character)
in the following example:

```{r, eval=TRUE}
num_logical <- c(1, 2, 3, TRUE)
char_logical <- c("a", "b", "c", TRUE)
combined_logical <- c(num_logical, char_logical)
```

:::::::::::::::  solution

## Solution

Only one. Il n'y a pas de mémoire des types de données passés et la conversion ("coercition") se produit la première fois que le vecteur est évalué. Therefore, the `TRUE`
in `num_logical` gets converted into a `1` before it gets converted
into `"1"` in `combined_logical`.

```{r}
combined_logical
```

:::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::  challenge

## Défi:

In R, we call converting objects from one class into another class
_coercion_. These conversions happen according to a hierarchy,
whereby some types get preferentially coerced into other types. Pouvez-vous dessiner un diagramme qui représente la hiérarchie de la façon dont ces types de données sont forcés ?

:::::::::::::::  solution

## Solution

logical → numeric → character ← logical

:::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::::

```{r, echo=FALSE, eval=FALSE, purl=TRUE}
## We've seen that atomic vectors can be of type character, numeric, integer, and
## logical. But what happens if we try to mix these types in a single
## vector?

## What will happen in each of these examples? (hint: use `class()` to
## check the data type of your object)
num_char <- c(1, 2, 3, "a")

num_logical <- c(1, 2, 3, TRUE)

char_logical <- c("a", "b", "c", TRUE)

tricky <- c(1, 2, 3, "4")

## Why do you think it happens?

## You've probably noticed that objects of different types get
## converted into a single, shared type within a vector. In R, we call
## converting objects from one class into another class
## _coercion_. These conversions happen according to a hierarchy,
## whereby some types get preferentially coerced into other types. Can
## you draw a diagram that represents the hierarchy of how these data
## types are coerced?
```

## Extraire des valeurs d'un vecteur (Subsetting)

If we want to extract one or several values from a vector, we must
provide one or several indices in square brackets. For instance:

```{r, results="show", purl=TRUE}
molecules <- c("dna", "rna", "peptide", "protein")
molecules[2]
molecules[c(3, 2)]
```

We can also repeat the indices to create an object with more elements
than the original one:

```{r, results="show", purl=TRUE}
more_molecules <- molecules[c(1, 2, 3, 2, 1, 4)]
more_molecules
```

En R, les indices commencent à 1. Les langages de programmation comme Fortran, MATLAB,
Julia et R commencent à compter à 1, car c'est ce que font généralement les êtres humains. Languages in the C family (including C++, Java, Perl,
and Python) count from 0 because that's simpler for computers to do.

En utilisant des indices négatifs, on peut obtenir tous les éléments d'un vecteur
sauf ceux spécifiés par les indices négatifs :

```{r}
molecules ## all molecules
molecules[-1] ## all but the first one
molecules[-c(1, 3)] ## all but 1st/3rd ones
molecules[c(-1, -3)] ## all but 1st/3rd ones
```

## Conditional subsetting

Another common way of subsetting is by using a logical vector. `TRUE` will
select the element with the same index, while `FALSE` will not:

```{r, purl=TRUE}
weight_g <- c(21, 34, 39, 54, 55)
weight_g[c(TRUE, FALSE, TRUE, TRUE, FALSE)]
```

Généralement, ces vecteurs logiques ne sont pas tapés à la main, mais sont le résultat d'autres fonctions ou tests logiques. Par exemple, si vous souhaitez sélectionner uniquement les valeurs supérieures à 50 :

```{r, purl=TRUE}
## will return logicals with TRUE for the indices that meet
## the condition
weight_g > 50
## so we can use this to select only the values above 50
weight_g[weight_g > 50]
```

Vous pouvez combiner plusieurs tests en utilisant `&` (les deux conditions sont vraies, AND) ou `|` (au moins une des conditions est vraie, OR) :

```{r, results="show", purl=TRUE}
weight_g[weight_g < 30 | weight_g > 50]
weight_g[weight_g >= 30 & weight_g == 21]
```

Ici, `<` signifie "inférieur à", `>` signifie "supérieur à", `>=` signifie
"supérieur ou égal à" et `==` signifie "égal à". Le double signe égal `==` est un test d'égalité numérique entre les côtés gauche et droit, et ne doit pas être confondu avec le signe simple `=`, qui effectue une affectation de variable (similaire à `<-`).

Une tâche courante consiste à rechercher certaines chaînes de caractères dans un vecteur.  On pourrait utiliser l'opérateur "ou" `|` pour tester l'égalité de plusieurs valeurs, mais cela peut rapidement devenir fastidieux. La fonction `%in%` permet de tester si l'un des éléments d'un vecteur de recherche est trouvé :

```{r, purl=TRUE}
molecules <- c("dna", "rna", "protein", "peptide")
molecules[molecules == "rna" | molecules == "dna"] # returns both rna and dna
molecules %in% c("rna", "dna", "metabolite", "peptide", "glycerol")
molecules[molecules %in% c("rna", "dna", "metabolite", "peptide", "glycerol")]
```

:::::::::::::::::::::::::::::::::::::::  challenge

## Défi:

À votre avis, pourquoi est-ce `"four" > "five"` (`"quatre" > "cinq"`) renvoie `TRUE` ?

:::::::::::::::  solution

## Solution

```{r}
"four" > "five"
```

Lorsque vous utilisez `>` ou `<` sur des chaînes de caractère, R compare leur ordre alphabétique.
Here `"four"` comes after `"five"`, and therefore is _greater than_
it.

:::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::::

## Noms d'éléments d'un vecteur

It is possible to name each element of a vector. Le code ci-dessous montre un exemple d'un vecteur dont les éléments n'ont initialement aucun nom, et comment on peut ensuite définir et récupérer les noms des éléments.

```{r}
x <- c(1, 5, 3, 5, 10)
names(x) ## no names
names(x) <- c("A", "B", "C", "D", "E")
names(x) ## now we have names
```

Lorsqu'un vecteur possède des noms, il est possible d'accéder aux éléments par leur nom, en plus de par leur index.

```{r}
x[c(1, 3)]
x[c("A", "C")]
```

## Missing data

Comme R a été conçu pour analyser des jeux de données, il inclut le concept de
données manquantes (ce qui est rare dans d'autres langages de programmation). Les données manquantes sont représentées dans les vecteurs par `NA` (pour _not applicable_).

Lorsque vous effectuez des opérations sur des nombres, la plupart des fonctions renverront `NA` si les données avec lesquelles vous travaillez incluent des valeurs manquantes. Cette fonctionnalité par défaut rend plus difficile l'ignorance des cas où vous avez affaire à des données manquantes.  Vous pouvez ajouter l'argument `na.rm = TRUE` pour calculer le résultat en ignorant les valeurs manquantes (`na.rm` peut se traduire par "_remove NA_", où "_remove_" signifie "enlever" en anglais).

```{r}
heights <- c(2, 4, 4, NA, 6)
mean(heights)
max(heights)
mean(heights, na.rm = TRUE)
max(heights, na.rm = TRUE)
```

Si vos données incluent des valeurs manquantes, vous souhaiterez peut-être vous familiariser avec les fonctions `is.na()`, `na.omit()` et `complete.cases()`. Voici quelques exemples.

```{r}
## Extrait les éléments qui ne sont pas manquants.
heights[!is.na(heights)]

## Renvois un objet dont les cas incomplets ont été supprimés. 
## L'objet renvoyé est un vecteur atomique du type "numeric"
## (ou "double").
na.omit(heights)

## Extrait les éléments qui représentent des cas complets.
## L'objet renvoyé est un vecteur atomique du type "numeric"
## (ou "double").
heights[complete.cases(heights)]
```

:::::::::::::::::::::::::::::::::::::::  challenge

## Défi:

1. En utilisant ce vecteur de hauteurs en pouces (_inches_), créez un nouveau vecteur en supprimant les NA.

```{r}
heights <- c(63, 69, 60, 65, NA, 68, 61, 70, 61, 59, 64, 69, 63, 63, NA, 72, 65, 64, 70, 63, 65)
```

2. Use the function `median()` to calculate the median of the `heights` vector.
3. Utilisez R pour déterminer combien de personnes dans l’échantillon mesurent plus de 67 pouces.

:::::::::::::::  solution

## Solution

```{r, purl=TRUE}
heights_no_na <- heights[!is.na(heights)]
## or
heights_no_na <- na.omit(heights)
```

```{r, purl=TRUE}
median(heights, na.rm = TRUE)
```

```{r, purl=TRUE}
heights_above_67 <- heights_no_na[heights_no_na > 67]
length(heights_above_67)
```

:::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::::

## Generating vectors {#sec:genvec}

```{r, echo=FALSE}
set.seed(1)
```

### Constructors

There exists some functions to generate vectors of different type. Pour
générer un vecteur de valeurs numériques, on peut utiliser le constructeur `numeric()`, en lui fournissant la longueur du vecteur de sortie comme paramètre. The values will be initialised with 0.

```{r, purl=TRUE}
numeric(3)
numeric(10)
```

Note that if we ask for a vector of numerics of length 0, we obtain
exactly that:

```{r, purl=TRUE}
numeric(0)
```

There are similar constructors for characters and logicals, named
`character()` and `logical()` respectively.

:::::::::::::::::::::::::::::::::::::::  challenge

## Défi:

Quelles sont les valeurs par défaut pour les vecteurs de caractères et les vecteurs logiques ?

:::::::::::::::  solution

## Solution

```{r, purl=TRUE}
character(2) ## the empty character
logical(2)   ## FALSE
```

:::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::::

### Replicate elements

The `rep` function allow to repeat a value a certain number of
times. If we want to initiate a vector of numerics of length 5 with
the value -1, for example, we could do the following:

```{r, purl=TRUE}
rep(-1, 5)
```

De même, pour générer un vecteur rempli de valeurs manquantes, ce qui
est souvent une bonne façon de commencer, sans poser d'hypothèses sur les données qui seront collectées :

```{r, purl=TRUE}
rep(NA, 5)
```

`rep` can take vectors of any length as input (above, we used vectors
of length 1) and any type. Par exemple, si nous voulions répéter cinq fois les valeurs 1, 2 et 3, nous procéderions comme suit :

```{r, purl=TRUE}
rep(c(1, 2, 3), 5)
```

:::::::::::::::::::::::::::::::::::::::  challenge

## Défi:

Et si nous voulions répéter les valeurs 1, 2 et 3 cinq fois, mais obtenir cinq 1, cinq 2 et cinq 3 dans cet ordre, comment devrions-nous procéder ? Il existe deux possibilités: voir `?rep` ou `?sort` pour obtenir de l'aide.

:::::::::::::::  solution

## Solution

```{r, purl=TRUE}
rep(c(1, 2, 3), each = 5)
sort(rep(c(1, 2, 3), 5))
```

:::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::::

### Génération de séquences

Another very useful function is `seq`, to generate a sequence of
numbers. For example, to generate a sequence of integers from 1 to 20
by steps of 2, one would use:

```{r, purl=TRUE}
seq(from = 1, to = 20, by = 2)
```

La valeur par défaut de `by` est 1 et, étant donné que la génération d'une séquence d'une valeur à une autre avec des pas de 1 est fréquemment utilisée,
il existe un raccourci :

```{r, purl=TRUE}
seq(1, 5, 1)
seq(1, 5) ## default by
1:5
```

To generate a sequence of numbers from 1 to 20 of final length of 3,
one would use:

```{r, purl=TRUE}
seq(from = 1, to = 20, length.out = 3)
```

### Random samples and permutations

Un dernier groupe de fonctions utiles sont celles qui génèrent des données aléatoires. La première, `sample`, génère une permutation aléatoire d'un autre vecteur. Par exemple, pour tirer au sort un ordre aléatoire de 10 étudiants
pour leur examen oral, j'attribue d'abord à chaque étudiant·e un numéro de 1 à dix (par exemple en fonction de l'ordre alphabétique de leurs noms) puis :

```{r, purl=TRUE}
sample(1:10)
```

Without further arguments, `sample` will return a permutation of all
elements of the vector. If I want a random sample of a certain size, I
would set this value as the second argument. Below, I sample 5 random
letters from the alphabet contained in the pre-defined `letters` vector:

```{r, purl=TRUE}
sample(letters, 5)
```

Si je voulais une sortie plus grande que le vecteur d'entrée, ou pouvoir
tirer au sort certains éléments plusieurs fois, je devrais définir l'argument `replace` à `TRUE` :

```{r, purl=TRUE}
sample(1:5, 10, replace = TRUE)
```

:::::::::::::::::::::::::::::::::::::::  challenge

## Défi:

En essayant les fonctions ci-dessus, vous aurez réalisé que les échantillons
sont effectivement aléatoires et qu'on n'obtient pas deux fois la même permutation. Pour pouvoir reproduire ces tirages aléatoires, on peut définir manuellement la "graine d'échantillonage" de nombres aléatoires avec la fonction `set.seed()`
avant de tirer l'échantillon aléatoire.

Test this feature with your neighbour. Tirez d'abord deux permutations aléatoires
de « 1:10 » indépendamment et observez que vous obtenez
résultats différents.

Définissez maintenant la graine avec, par exemple, `set.seed(123)` et répétez le tirage au sort. Observez que vous obtenez désormais les mêmes tirages.

Repeat by setting a different seed.

:::::::::::::::  solution

## Solution

Different permutations

```{r, purl=TRUE}
sample(1:10)
sample(1:10)
```

Same permutations with seed 123

```{r, purl=TRUE}
set.seed(123)
sample(1:10)
set.seed(123)
sample(1:10)
```

A different seed

```{r, purl=TRUE}
set.seed(1)
sample(1:10)
set.seed(1)
sample(1:10)
```

:::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::::

### Échantillonner à partir d'une distribution normale

La dernière fonction que nous allons voir est `rnorm`, qui tire un échantillon aléatoire à partir d'une distribution normale. Two normal distributions of means 0
and 100 and standard deviations 1 and 5, noted _N(0, 1)_ and
_N(100, 5)_, are shown below.

```{r, echo=FALSE, fig.width=12, fig.height=6, fig.cap="Two normal distributions: *N(0, 1)* on the left and *N(100, 5)* on the right."}
par(mfrow = c(1, 2))
plot(density(rnorm(1000)), main = "", sub = "N(0, 1)")
plot(density(rnorm(1000, 100, 5)), main = "", sub = "N(100, 5)")
```

Les trois arguments, `n`, `mean` et `sd`, définissent la taille de l'échantillon, et les paramètres de la distribution normale, c'est-à-dire sa moyenne
et son écart type. Les valeurs par défaut de ces derniers sont 0 et 1.

```{r, purl=TRUE}
rnorm(5)
rnorm(5, 2, 2)
rnorm(5, 100, 5)
```

Maintenant que nous avons appris à écrire des scripts et connaissons les bases des structures de données de R, nous sommes prêts à commencer à travailler avec des données plus volumineuses et à en apprendre davantage sur les "data frames" (tables de données).

:::::::::::::::::::::::::::::::::::::::: keypoints

- How to interact with R

::::::::::::::::::::::::::::::::::::::::::::::::::
